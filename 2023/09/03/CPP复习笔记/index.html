<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>C++复习笔记 | movic</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[toc] 记录一些容易忘记的C++知识C++知识体系较为庞杂，学得不够系统，对知识点进行记录和定期复盘是很有必要的。现在想重新过一遍《C++ Primer Plus》，把一些被遗忘了的和还未学习的知识记录下来，方便日后查阅。 正篇开始1. 头文件C语言的头文件使用扩展名.h，C++则没有扩展名，但仍然可以使用C语言的.h文件。有些C头文件被转换为C++头文件，并被重新命名，去掉了扩展名.h，并在">
<meta property="og:type" content="article">
<meta property="og:title" content="C++复习笔记">
<meta property="og:url" content="http://yoursite.com/2023/09/03/CPP%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="movic">
<meta property="og:description" content="[toc] 记录一些容易忘记的C++知识C++知识体系较为庞杂，学得不够系统，对知识点进行记录和定期复盘是很有必要的。现在想重新过一遍《C++ Primer Plus》，把一些被遗忘了的和还未学习的知识记录下来，方便日后查阅。 正篇开始1. 头文件C语言的头文件使用扩展名.h，C++则没有扩展名，但仍然可以使用C语言的.h文件。有些C头文件被转换为C++头文件，并被重新命名，去掉了扩展名.h，并在">
<meta property="og:locale">
<meta property="article:published_time" content="2023-09-03T02:21:13.000Z">
<meta property="article:modified_time" content="2023-09-03T08:35:34.709Z">
<meta property="article:author" content="movic">
<meta property="article:tag" content="CPP">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="movic" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">movic</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-CPP复习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/09/03/CPP%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2023-09-03T02:21:13.000Z" itemprop="datePublished">2023-09-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++复习笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1><span id="记录一些容易忘记的c知识">记录一些容易忘记的C++知识</span></h1><p>C++知识体系较为庞杂，学得不够系统，对知识点进行记录和定期复盘是很有必要的。现在想重新过一遍《C++ Primer Plus》，把一些被遗忘了的和还未学习的知识记录下来，方便日后查阅。</p>
<h2><span id="正篇开始">正篇开始</span></h2><h3><span id="1-头文件">1. 头文件</span></h3><p>C语言的头文件使用扩展名<code>.h</code>，C++则没有扩展名，但仍然可以使用C语言的<code>.h</code>文件。有些C头文件被转换为C++头文件，并被重新命名，去掉了扩展名<code>.h</code>，并在文件名称前面加上前缀c，例如，C++版本的<code>math.h</code>为<code>cmath</code>。没有<code>.h</code>扩展名的头文件可以包含名称空间。</p>
<h3><span id="2-函数">2. 函数</span></h3><ol>
<li><p>C/C++不允许将函数定义嵌套在另一个函数定义中；</p>
</li>
<li><p>在C++中，不指定参数列表时应使用省略号<code>void func(...)&#123; &#125;</code>，通常，仅当与接受可变参数的C函数交互时才需要这样做；</p>
</li>
<li><p>C++函数不能直接返回数组，但可以将数组作为结构或对象的组成部分来返回；</p>
</li>
<li><p>函数返回对象时，有可能使得下面的代码能够通过编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vector v1, v2;</span><br><span class="line">Vector v3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载加法运算符</span></span><br><span class="line">Vector Vector::<span class="keyword">operator</span>+(<span class="keyword">const</span> Vector &amp; rv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Vector(x + rv.x, y + rv.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v3 = v1 + v2;  <span class="comment">// 正常使用逻辑</span></span><br><span class="line"></span><br><span class="line">v1 + v2 = v3; <span class="comment">// 能够通过编译，先执行operator+，再执行operator=</span></span><br></pre></td></tr></table></figure>
<p>为防止在使用赋值运算符的时候出错，可以把返回值设置为<code>const</code>类型。</p>
</li>
<li><p>传递数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> [], <span class="keyword">int</span>)</span></span>;  <span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>)</span></span>;  <span class="comment">// 另一种形式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;  <span class="comment">// 函数定义，sizeof array将等于指针类型长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*为防止函数无意中修改数组的内容，可在声明形参时使用关键字const*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *, <span class="keyword">int</span>)</span></span>;  <span class="comment">// 这表明该形参指针指向的是常量数据，不允许通过该指针进行修改</span></span><br></pre></td></tr></table></figure></li>
<li><p>函数不能返回字符串，但是可以在函数体中申请内存空间，返回该内存空间的地址，以此来返回一个字符串；</p>
</li>
<li><p>函数的地址：</p>
<p>函数的地址是存储其机器语言代码的内存的开始地址。==函数名==就是函数的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明函数指针</span></span><br><span class="line"><span class="keyword">double</span> (*pf)(<span class="keyword">int</span>);  <span class="comment">// 可以首先编写函数的原型，然后用(*pf)替换函数名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过函数指针调用函数</span></span><br><span class="line"><span class="keyword">double</span> y = (*pf)(x); </span><br><span class="line"><span class="keyword">double</span> y = pf(x);  <span class="comment">// C++中也允许像使用函数名那样使用pf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*声明函数指针数组，运算符[]的优先级高于*，所以pf[3]表明其是一个包含三个元素的数组，*pf[3]表明其是一个包含三个指针的数组，其他部分的内容则说明这些指针是函数指针。此处不能使用auto关键字，因为自动类型推断只能用于单值初始化，不能用于初始化列表。但是声明数组pf后，可以使用auto来声明同类型的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * (*pf[<span class="number">3</span>])(<span class="keyword">const</span> <span class="keyword">double</span> *, <span class="keyword">int</span>) = &#123;f1, f2, f3&#125;;</span><br><span class="line"><span class="keyword">auto</span> pa = pf;</span><br><span class="line">pf[<span class="number">0</span>](cpd, <span class="number">3</span>);  <span class="comment">// 通过函数指针数组和索引调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * (*(*pd)[<span class="number">3</span>])(<span class="keyword">const</span> <span class="keyword">double</span> *, <span class="keyword">int</span>) = &amp;pf;  <span class="comment">// 指向函数指针数组的指针，我的天呐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用typedef进行简化*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">double</span> * (*p_fun)(<span class="keyword">const</span> <span class="keyword">double</span> *, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">p_fun p1 = f1;  <span class="comment">// 声明函数指针变量，p_fun为新类型的别名</span></span><br><span class="line">p_fun p2[<span class="number">3</span>] = &#123;f1, f2, f3&#125;;  <span class="comment">// 创建函数指针数组，很方便</span></span><br><span class="line">p_fun (*pd)[<span class="number">3</span>] = &amp;f1;  <span class="comment">// 创建指向函数指针数组的指针</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

</li>
</ol>
<p>以下是C++特有的内容：</p>
<ol>
<li><p>内联函数：</p>
<p>C++编译器将使用相应的函数代码替换内联函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本。</p>
<p>要使用这项特性，必须采取下述措施之一：</p>
<ul>
<li>在函数声明前加上关键字inline；</li>
<li>在函数定义前加上关键字inline。</li>
</ul>
<p>通常的做法是省略原型，将整个定义（即函数头和所有函数代码）放在本应提供原型的地方。</p>
<p>==注意==：</p>
<ul>
<li>如果函数过大，编译器可能不允许将该其作为内联函数。</li>
<li>内联函数不能递归。</li>
</ul>
<p>内联函数类似C中的宏，但是内联函数有着按值传参等函数特性，而宏只是简单的替换。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">square(c++);  <span class="comment">// 对于内联函数，c只增加一次</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line">SQUARE(c++);  <span class="comment">// 对于宏，变量c将自增两次，即((c++) * (C++))</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用变量：</p>
<p>引用是已定义的变量的别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName &amp; ref_name = variable;  <span class="comment">// 必须在声明引用时将其进行初始化</span></span><br></pre></td></tr></table></figure>
<p>引用与常指针类似，声明之后不能更改为其他变量的引用。如果修改引用，实际上是对原变量进行赋值；</p>
<p>如果函数中不修改变量的值，同时又想使用引用，则应使用常量引用（即不能通过引用修改原变量的值）；</p>
<p>如果函数的形参类型为引用（非const引用）类型，则传递的参数只能是对应类型的变量，而不能是表达式；</p>
<p>如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。</p>
<p>C++ 11新增了右值引用，可指向右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> &amp;&amp; ref = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<p>使用函数返回值给变量赋值：<code>int ret = func(var1, var2);</code>，如果函数返回一个结构（或其他类型），则整个结构会被复制到一个临时位置，再将这个拷贝赋值给变量。但在返回值为引用时，将直接把结构复制到变量中，其效率更高。</p>
<p>假如要使用引用返回值，但又不允许对引用返回值进行赋值，只需将返回值类型声明为const引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> &amp; <span class="title">sum</span><span class="params">(<span class="keyword">int</span> &amp;, <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line">sum(a, b) = c;  <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>
<p>==返回引用的函数实际上是被引用变量的别名==。</p>
</li>
<li><p>默认参数：</p>
<p>只有原型指定了默认值。函数定义与没有默认参数时完全相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">1</span>, <span class="keyword">int</span> c = <span class="number">2</span>)</span></span>;  <span class="comment">// 带默认参数列表的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span> = <span class="number">1</span>, <span class="keyword">int</span> = <span class="number">2</span>)</span></span>;  <span class="comment">// 这种形式实测也可以</span></span><br></pre></td></tr></table></figure></li>
<li><p>重载函数：</p>
<p>函数重载的关键是函数的参数列表——也称为函数特征标（==仅返回值不同不是函数重载==）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> &amp;x)</span></span>;  <span class="comment">// 编译器无法确定究竟选择哪个原型。如果传参是右值cube(3.0)，实际上编译也能通过，但是传参是变量就不行了</span></span><br></pre></td></tr></table></figure>
<p>当参数不与任何原型匹配，C++将尝试使用标准类型转换进行匹配。如果重载函数中存在唯一的转换方式，则调用该重载函数，否则编译器报错。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">long</span>)</span></span>;  <span class="comment">// 两个重载函数头</span></span><br><span class="line"></span><br><span class="line">cube(<span class="number">3.14</span>);  <span class="comment">// 参数3.14为double型，不与任何原型匹配，将进行标准类型转换。在这里可以转int和long，有两种选择，因此编译器将报错</span></span><br></pre></td></tr></table></figure>
<p>当同时有带const和非const两个原型时，传递const参数时调用const原型，传递常规参数时，优先调用非const原型（==仅针对指针==）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> *)</span></span>;  <span class="comment">// 同时有带const和非const两个原型</span></span><br></pre></td></tr></table></figure>
<p>对于重载引用参数，C++将调用最匹配的版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">double</span> &amp;)</span></span>;  <span class="comment">// 匹配可修改的左值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> &amp;)</span></span>;  <span class="comment">// 匹配const的左值或右值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">double</span> &amp;&amp;)</span></span>;  <span class="comment">// 匹配右值</span></span><br></pre></td></tr></table></figure>
<p>对于同时出现重载函数和默认参数，如果出现二义性，则编译不通过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">int</span> = <span class="number">2</span>)</span></span>;  <span class="comment">// 带默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">double</span>)</span></span>;  <span class="comment">// 不带默认参数</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">3.14</span>, <span class="number">4</span>);  <span class="comment">// OK</span></span><br><span class="line">show(<span class="number">3.14</span>);  <span class="comment">// 对重载函数调用不明确，编译器报错</span></span><br></pre></td></tr></table></figure></li>
<li><p>C++将区分常量和非常量函数的特征标；</p>
</li>
<li><p>函数模板：</p>
<p>通过将类型作为参数传递给模板，可使编译器生成该类型的函数。模板并不创建任何函数，只是告诉编译器如何定义函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnyType&gt;  <span class="comment">// 建立函数模板，typename可以用class代替，AnyType通常使用T。注意，每个模板函数的声明和定义的位置都需要先建立函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(AnyType &amp;a, AnyType &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AnyType temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多种类型的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T1 &amp;, T2 &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板与重载结合</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T a[], T b[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">        b[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显式具体化可用于为特定数据类型创建特定的函数定义。</span></span><br><span class="line"><span class="comment">Q：为什么不直接定义函数呢，非模板版本优先级又高，想不明白。A：其实也可以定义普通的非模板函数</span></span><br><span class="line"><span class="comment">如果有多个原型，则编译器在选择原型时，非模板版本优先于显式具体化和模板版本，而显式具体化优先于使用模板生成的版本。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显式具体化语法。注意，该原型必须位于其他模板函数之后。Swap&lt;complex&gt;中的&lt;complex&gt;是可选的，</span></span><br><span class="line"><span class="comment">因为函数的参数表明，这是complex的一个具体化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> Swap&lt;<span class="built_in">complex</span>&gt;(<span class="built_in">complex</span> &amp;, <span class="built_in">complex</span> &amp;);</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="built_in">complex</span> &amp;, <span class="built_in">complex</span> &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 使用显式具体化时，一定要仔细检查函数的特征标和返回值，否则编译出错很难Debug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化，本质上是手动创建了一个函数定义，而函数模板使编译器可以生成函数定义的方式属于隐式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> Swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> &amp;, <span class="keyword">int</span> &amp;);  <span class="comment">// 直接命令编译器创建int类型函数定义实例</span></span><br><span class="line"><span class="comment">// 也可以在程序中使用函数来创建显式实例化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// 这里的模板与函数调用add(x, m)不匹配，因为该模板要求函数两个参数的类型相同。但通过使用add&lt;double&gt;(x, m)，可强制为double类型实例化，并将参数m强制转换为double类型，以便于函数的第二个参数与add&lt;double&gt;(double, double)匹配。</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; add&lt;<span class="keyword">double</span>&gt;(x, m) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 显式实例化</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; add(x, x) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 隐式实例化</span></span><br></pre></td></tr></table></figure>
<p>编译器选择使用哪个函数版本的步骤（内容太多太难记住，需要再查书吧）：</p>
<ol>
<li><p>列出所有同名函数；</p>
</li>
<li><p>列出参数个数匹配的函数；</p>
</li>
<li><p>确定是否有最佳的可行函数</p>
<p>通常，从最佳到最差的顺序如下所述：</p>
<ol>
<li>完全匹配，但常规函数优于模板；</li>
<li>提升转换（例如，char和short自动转int，float自动转换为double）；</li>
<li>标准转换（例如，int转换为char，long转换为double）。</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">lesser</span><span class="params">(T, T)</span></span>;  <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lesser</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">// #2</span></span><br><span class="line"></span><br><span class="line">lesser(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 调用#2</span></span><br><span class="line">lesser(<span class="number">3.14</span>, <span class="number">2.0</span>);  <span class="comment">// 调用#1</span></span><br><span class="line">lesser&lt;&gt;(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// &lt;&gt;指出编译器应选择模板函数而不是非模板函数</span></span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3><span id="3-整型">3. 整型</span></h3><p>C++的基本整型有5种，每种类型都有符号版本和无符号版本，因此总共有10种类型。</p>
<table>
<thead>
<tr>
<th align="center">整型</th>
<th align="center">最小长度</th>
<th align="center"></th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16位</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">至少与short一样长</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">至少32位，且至少与int一样长</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">至少64位，且至少与long一样长</td>
<td align="center"></td>
<td align="center">C++ 11新增</td>
</tr>
</tbody></table>
<h3><span id="4-浮点型">4. 浮点型</span></h3><p>C++有3种浮点类型：float，double和long double。</p>
<h3><span id="5-运算符">5. 运算符</span></h3><p>sizeof：对类型名（如int）使用sizeof运算符时，应将名称放在括号中；但对变量名使用该运算符，括号是可选的。如果将sizeof运算符用于数组名，得到的将是整个数组中的字节数。</p>
<h3><span id="6-变量初始化">6. 变量初始化</span></h3><ol>
<li><p>C++特有而C语言没有的初始化语法：<code>int power(100);</code></p>
</li>
<li><p>C++ 11的大括号初始化器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> emus&#123;<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> rheas = &#123;<span class="number">12</span>&#125;; <span class="comment">// 可以使用等号，也可以不使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rocs = &#123;&#125;;  <span class="comment">// 大括号内可以不包含任何东西，变量将被初始化为零</span></span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3><span id="7-输入输出">7. 输入输出</span></h3><ol>
<li><p><code>dec</code>，<code>hex</code>，<code>oct</code>控制符，用于指示以不同进制格式显示整数：<code>cout &lt;&lt; hex;</code>。默认为十进制，在修改格式之前，原来的格式将一直有效；</p>
</li>
<li><p><code>cout.setf(ios::boolalpha);</code>设置了一个标记，该标记命令cout显示true和false，而不是1和0；</p>
</li>
<li><p><code>cin.eof()</code>或<code>cin.fail()</code>用于检测EOF。当用于测试时，需要在读取之后才调用这两个函数（可以二选一）；</p>
</li>
<li><p><code>cin.get(char)</code>的返回值是一个cin对象。cin对象可以转换为bool值，如果最后一次读取成功了，则转换得到的bool值为true，否则为false：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>);  <span class="comment">// 这比!cin.eof()或!cin.fail()更加通用，因为它可以检测到其他失败原因，如磁盘故障</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get(ch))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3><span id="8-常量">8. 常量</span></h3><ol>
<li>除非有理由存储为其他类型（如使用了后缀，或值太大，不能存储为int），否则C++将整型常量存储为int类型：</li>
</ol>
<table>
<thead>
<tr>
<th align="center">后缀</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">l或L</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">u或U</td>
<td align="center">unsigned int</td>
</tr>
<tr>
<td align="center">ul或lu</td>
<td align="center">unsigned long</td>
</tr>
<tr>
<td align="center">ll或LL</td>
<td align="center">long long</td>
</tr>
<tr>
<td align="center">ull、Ull、uLL、ULL</td>
<td align="center">unsigned long long</td>
</tr>
</tbody></table>
<ol start="2">
<li>在C++中，对十进制整数采用的规则，与十六进制和八进制稍微有些不同。对于不带后缀的十进制整数，将使用<code>int</code>，<code>long</code>或<code>long long</code>中的最小类型来表示；对于不带后缀的十六进制或八进制整数，将使用<code>int</code>，<code>unsigned int</code>，<code>long</code>，<code>unsigned long</code>，<code>long long</code>和<code>unsigned long long</code>中的最小类型来表示；</li>
<li>在默认情况下，浮点常量都属于double类型，如果希望常量为float类型，使用f或F后缀，对于long double类型，可使用l或L后缀。</li>
</ol>
<h3><span id="9-字符与字符串">9. 字符与字符串</span></h3><ol>
<li><p>C++ 11新增<code>char16_t</code>和<code>char32_t</code>类型，二者均为无符号类型。C++ 11使用前缀<code>u</code>表示<code>char16_t</code>字符常量和字符串常量，如<code>u&#39;C&#39;</code>和<code>u&quot;be good&quot;</code>；对于<code>char32_t</code>类型则使用前缀<code>U</code>；</p>
</li>
<li><p>char数组只有当最后一个元素为<code>\0</code>时才是字符串；</p>
</li>
<li><pre><code class="c++">char bird[11] = &quot;Mr. Cheeps&quot;;
char fish[] = &quot;Bubbles&quot;;  // let the compiler count
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 字符串拼接：任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个字符串；</span><br><span class="line"></span><br><span class="line">5. &#96;&#96;&#96;c++</span><br><span class="line">   #include &lt;cstring&gt;  &#x2F;&#x2F; for the strlen(), strcpy(), strcat() function</span><br><span class="line">   strcpy(charr1, charr2);  &#x2F;&#x2F; copy charr2 to charr1</span><br><span class="line">   strcat(charr1, charr2);  &#x2F;&#x2F; append contents of charr2 to charr1</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>cin</code>使用空白（空格、制表符和换行符）来确定字符串结束位置，<code>cin</code>在获取字符数组输入时只读取一个单词；</p>
</li>
<li><p>```c++<br>char c = ‘c’;<br>cout &lt;&lt; ++c;  // 输出为字符<br>cout &lt;&lt; c + 1;  // 输出为ascii编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">8. 面向行的输入：</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;c++</span><br><span class="line">   cin.getline(arrayName, arraySize);  &#x2F;&#x2F; 读取并丢弃换行符</span><br><span class="line">   cin.get(arrayName, arraySize);  &#x2F;&#x2F; 不读取换行符</span><br><span class="line">   cin.get();  &#x2F;&#x2F; 不带参数，可以读取任意一个字符，包括换行符</span><br><span class="line">   </span><br><span class="line">   char ch;</span><br><span class="line">   cin.get(ch);  &#x2F;&#x2F; Q：ch是如何赋值的？A：使用了引用</span><br></pre></td></tr></table></figure></li>
<li><p>string类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用string类，必须包含头文件string，string类位于名称空间std中</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str = &#123;<span class="string">&quot;Hello World&quot;</span>&#125;;  <span class="comment">// 列表初始化</span></span><br><span class="line"><span class="built_in">string</span> str &#123;<span class="string">&quot;Hello world&quot;</span>&#125;;  <span class="comment">// 省略等号的列表初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span> <span class="params">(<span class="string">&quot;Hello world&quot;</span>)</span></span>;  <span class="comment">// 圆括号初始化</span></span><br><span class="line">str_copy = str;  <span class="comment">// 允许赋值</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;  <span class="comment">// 可以使用cin来将键盘输入存储到string对象中，会自动调整str的长度</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str;  <span class="comment">// 可以使用cout来显示string对象</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str[<span class="number">2</span>];  <span class="comment">// 支持索引操作</span></span><br><span class="line">str1 == str2;  <span class="comment">// 支持==、!=、&gt;、&lt;、&gt;=、&lt;=等比较运算</span></span><br><span class="line"></span><br><span class="line">str3 = str1 + str2;  <span class="comment">// 字符串合并</span></span><br><span class="line">str2 += str1;  <span class="comment">// 使用+=拼接</span></span><br><span class="line">str2 += <span class="string">&quot;Hello World!&quot;</span>;  <span class="comment">// 拼接C-风格字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = str.size();  <span class="comment">// 获取str的长度</span></span><br><span class="line"></span><br><span class="line">getline(<span class="built_in">cin</span>, str);  <span class="comment">// 区别于cin.getline(),一个是类成员函数，一个不是</span></span><br></pre></td></tr></table></figure></li>
<li><p>其他形式的字符串字面值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">u8&quot;Hello World&quot;</span>;  <span class="comment">// UTF-8</span></span><br><span class="line"><span class="string">R&quot;(&quot;Hello World&quot;)&quot;</span>;  <span class="comment">// 原始字符串，将&quot;(和)&quot;用作定界符，字符串中允许出现&quot;&quot;，如果字符串中需要出现)&quot;，可以自定义定界符,&quot;+*()+*&quot;，即&quot;(与)&quot;之间可以插入任意基本字符（空格、左右括号、斜杆和控制字符除外）共同组成定界符，但是左右插入的字符必须相同，如：</span></span><br><span class="line"><span class="string">R&quot;+*(&quot;(Hello World)&quot;)+*&quot;</span>;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3><span id="10-数组">10. 数组</span></h3><p>C++没有提供二维数组类型，但用户可以创建每个元素本身都是数组的数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建数组的通用格式</span></span><br><span class="line">typeName arrayName[arraySize];  <span class="comment">// arraySize必须是整型常数或者是const值，也可以是常量表达式</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">typeName arrayName[arraySize] = &#123;v1, v2, ..., vn&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化规则</span></span><br><span class="line"><span class="keyword">int</span> cards[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;  <span class="comment">// Ok</span></span><br><span class="line"><span class="keyword">int</span> cards[<span class="number">4</span>] &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;; <span class="comment">// Ok</span></span><br><span class="line"><span class="keyword">int</span> hand[<span class="number">4</span>];  <span class="comment">// Ok</span></span><br><span class="line">hand[<span class="number">4</span>] = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;  <span class="comment">// not allowed</span></span><br><span class="line">hand = cards;  <span class="comment">// 不允许数组赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> hotelTips[<span class="number">5</span>] = &#123;<span class="number">5.0</span>, <span class="number">2.5</span>&#125;;  <span class="comment">// 允许，编译器将其他元素置为0</span></span><br><span class="line"><span class="keyword">long</span> totals[<span class="number">500</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 全部初始化为0</span></span><br><span class="line"><span class="keyword">short</span> things[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>&#125;;  <span class="comment">// 编译器计算元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> earnings[<span class="number">4</span>] &#123;<span class="number">1.2e4</span>, <span class="number">1.6e4</span>, <span class="number">1.1e4</span>, <span class="number">1.7e4</span>&#125;;  <span class="comment">// okey with C++ 11</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> counts[<span class="number">10</span>] = &#123;&#125;;  <span class="comment">// C++ 11, 所有元素置为0</span></span><br><span class="line"><span class="keyword">long</span> plifs[] = &#123;<span class="number">25</span>, <span class="number">92</span>, <span class="number">3.0</span>&#125;;  <span class="comment">// 编译不通过，因为C++ 11列表初始化不允许缩窄</span></span><br></pre></td></tr></table></figure>




<h3><span id="11-结构体">11. 结构体</span></h3><p>C语言可以通过函数指针在结构体中包含成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newTypeName</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> e1[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> e2;</span><br><span class="line">    <span class="keyword">float</span> e3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newTypeName</span> <span class="title">x</span> =</span> &#123;<span class="string">&quot;a&quot;</span>, <span class="number">100</span>, <span class="number">3.14</span>&#125;;  <span class="comment">// C语言中不能省略关键字struct</span></span><br><span class="line">newTypeName x;  <span class="comment">// C++中可省略struct</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 11列表初始化，注意不能缩窄</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newTypeName</span> <span class="title">x</span> &#123;</span><span class="string">&quot;a&quot;</span>, <span class="number">100</span>, <span class="number">3.14</span>&#125;;  <span class="comment">// C++ 11列表初始化，可省略等号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newTypeName</span> <span class="title">x</span> &#123;</span>&#125;;  <span class="comment">// 括号内为空，则所有成员将被设置为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员赋值时，即使成员是数组，也能直接赋值</span></span><br><span class="line">newTypeName x = &#123;<span class="string">&quot;abc&quot;</span>, <span class="number">100</span>, <span class="number">3.14</span>&#125;;</span><br><span class="line">newTypeName y = x;  <span class="comment">// 成员赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明结构时定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newTypeName</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> e1[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> e2;</span><br><span class="line">    <span class="keyword">float</span> e3;</span><br><span class="line">&#125; x, y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明结构时定义变量并初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newTypeName</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> e1[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> e2;</span><br><span class="line">    <span class="keyword">float</span> e3;</span><br><span class="line">&#125; x = &#123;<span class="string">&quot;abc&quot;</span>, <span class="number">100</span>, <span class="number">3.14</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一次性结构变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> e1[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> e2;</span><br><span class="line">    <span class="keyword">float</span> e3;</span><br><span class="line">&#125; x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构数组及其初始化</span></span><br><span class="line">newTypeName x[<span class="number">2</span>] = </span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;a&quot;</span>, <span class="number">100</span>, <span class="number">3.14</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;b&quot;</span>, <span class="number">200</span>, <span class="number">2.71</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体位字段，字段类型应为整型或枚举</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SN : <span class="number">4</span>;  <span class="comment">// 4 bits for SN value</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> : <span class="number">4</span>;  <span class="comment">// 4 bits unused</span></span><br><span class="line">    <span class="keyword">bool</span> goodIn : <span class="number">1</span>;  <span class="comment">// 1 bit</span></span><br><span class="line">    <span class="keyword">bool</span> finish : <span class="number">1</span>;  <span class="comment">// 1 bit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3><span id="12-共用体">12. 共用体</span></h3><p>可以利用共用体的特性操作内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在结构中声明共用体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">structType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">id</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">long</span> id_num;</span><br><span class="line">        <span class="keyword">char</span> id_char[<span class="number">20</span>];</span><br><span class="line">    &#125; id_val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line">structType var;</span><br><span class="line">var.id_val.id_num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; var.id_val.id_char;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名共用体，共用体成员被视为结构体的两个成员</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">structType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">long</span> id_num;</span><br><span class="line">        <span class="keyword">char</span> id_char[<span class="number">20</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3><span id="13-枚举">13. 枚举</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> &#123;</span>red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只使用枚举常量，不创建枚举变量，可省略枚举类型名称</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举在表达式中可以提升为int类型，但int不允许赋值给枚举变量（取决于实现）</span></span><br><span class="line"><span class="keyword">int</span> color = red;  <span class="comment">// 合法操作</span></span><br><span class="line">spectrum color = spectrum (<span class="number">2</span>);  <span class="comment">// 合法，使用强制类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式设置枚举量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bits</span> &#123;</span>one = <span class="number">1</span>, two = <span class="number">2</span>, four = <span class="number">4</span>, eight = <span class="number">8</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bigstep</span> &#123;</span>first, second = <span class="number">100</span>, third&#125;;  <span class="comment">// first = 0, third = 101</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>zero, null = <span class="number">0</span>, one, full = <span class="number">1</span>&#125;;  <span class="comment">// 可以创建多个值相同的枚举量</span></span><br></pre></td></tr></table></figure>




<h3><span id="14-指针">14. 指针</span></h3><p>==问题==：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Q：指针变量所占空间为4个字节，那么超过4G的地址空间如何表示？</span><br><span class="line">A：指针变量不一定是4个字节，得看数据模型。</span><br><span class="line">Q：delete运算符是如何确定释放多少内存空间的？</span><br><span class="line">A：编译器通过分配额外的空间记录已分配的内存空间的长度。</span><br></pre></td></tr></table></figure>
<p><strong>空指针</strong>：有些程序员使用<code>(void *) 0</code>来标识空指针（空指针本身的内部表示可能不是零），还有程序员使用NULL，这是一个表示空指针的C语言宏。C++ 11新增了关键字<code>nullptr</code>，用于表示空指针，用法为：<code>pt = nullptr;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1, p2;  <span class="comment">// 注意p1为int*类型，p2为int类型</span></span><br><span class="line"></span><br><span class="line">typeName * pointer_name = <span class="keyword">new</span> typeName;  <span class="comment">// 动态分配内存</span></span><br><span class="line"><span class="comment">// 使用new运算符，如果内存分配失败，将引发异常，或者返回空指针，取决于实现</span></span><br><span class="line"><span class="keyword">delete</span> pointer_name;  <span class="comment">// 使用delete运算符释放内存</span></span><br><span class="line"></span><br><span class="line">typeName * pointer_name = <span class="keyword">new</span> typeName [num_elements];  <span class="comment">// 使用new创建动态数组</span></span><br><span class="line"><span class="keyword">delete</span> [] pointer_name;  <span class="comment">// 释放一个动态数组的内存</span></span><br><span class="line">pointer_name[<span class="number">0</span>];  <span class="comment">// 可以当做普通数组来访问每个元素</span></span><br><span class="line">pointer_name += <span class="number">1</span>;  <span class="comment">// 指针变量允许此操作，数组名则不允许</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++编译器对索引操作的转换</span></span><br><span class="line">arrayname[i] -&gt; *(arrayname + i);</span><br><span class="line">pointername[i] -&gt; *(pointername + i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> tell[<span class="number">10</span>];  <span class="comment">// 数组名tell表示第一个元素的地址，tell == &amp;tell[0]，tell + 1会将tell的值增加sizeof(short)</span></span><br><span class="line"><span class="keyword">short</span> (*pas)[<span class="number">10</span>] = &amp;tell;  <span class="comment">// 数组的地址，类型是short (*)[10]，pas + 1会将pas的值增加sizeof(short) * 10</span></span><br><span class="line"><span class="keyword">short</span> *pas[<span class="number">10</span>];  <span class="comment">// 定义十个元素为short *类型的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组内指针减法，得到的是两个被指向元素的间隔</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> * start = <span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">int</span> * stop = &amp;<span class="built_in">array</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> diff = stop - start;  <span class="comment">// diff == 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt;  <span class="comment">// 指向常量的指针，指向的值不一定是常量，但对pt而言，这个值是常量。C++禁止将const变量的地址赋值给非const的指针。pt可以指向其他的变量，但是同样不能修改指向的变量</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> pt = &amp;x;  <span class="comment">// 常指针，与定义常量不同，定义常指针时const放在类型后面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*仅当只有一层间接关系（如指针指向基本数据类型）时，才可以将非const地址或指针赋给const指针*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> **p2;</span><br><span class="line"><span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">13</span>;</span><br><span class="line">p2 = &amp;p1;  <span class="comment">// 第一步：not allowed</span></span><br><span class="line">*p2 = &amp;n;</span><br><span class="line">*p1 = <span class="number">10</span>;  <span class="comment">// 试图用常规指针修改const变量，由于第一步不通过，所以也不会到这一步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*二维数组传参*/</span></span><br><span class="line"><span class="comment">// 注意：列数不能省略，且传参时只能传递列数相同的二维数组</span></span><br><span class="line"><span class="comment">// 形参没有使用const，因为这里的形参是二级指针，而const只适用于一级指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> (*)[<span class="number">4</span>], <span class="keyword">int</span>)</span></span>;  <span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> [][<span class="number">4</span>], <span class="keyword">int</span>)</span></span>;  <span class="comment">// 这种格式也可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[][<span class="number">4</span>], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>];  <span class="comment">// 直接当做二维数组进行访问</span></span><br><span class="line">    *(*(<span class="built_in">array</span> + <span class="number">0</span>) + <span class="number">0</span>);  <span class="comment">// 等价的指针操作，比较复杂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3><span id="15-关键字">15. 关键字</span></h3><ol>
<li><p>const限定符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建常量的通用格式</span></span><br><span class="line"><span class="keyword">const</span> type name = value</span><br></pre></td></tr></table></figure>
<p>在C++（不是C语言）中，const全局变量的链接性为内部，就像是使用了static一样。这也是常量定义可以放在头文件，由多个源文件包含但并不产生冲突的原因。如有必要，可以使用extern关键字来覆盖默认的内部链接性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> status = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> status;  <span class="comment">// 其他文件引用该变量</span></span><br></pre></td></tr></table></figure>




</li>
</ol>
<ol start="2">
<li><p>auto关键字：</p>
<p>C++ 11新增了auto关键字，让编译器能够根据初始值的类型推断变量的类型。在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同。（注意，auto本来是一个C语言关键字，用于显式地指出变量为自动存储，所谓自动存储，就是代码块中定义的变量。实际上atuo几乎用不上）。</p>
</li>
<li><p>decltype关键字：</p>
<p>C++ 11新增了decltype关键字，可以将变量指定为与表达式相同的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression) var;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要多次声明，可结合使用typedef和decltype</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(x + y)</span> xytype</span>;</span><br><span class="line">xytype xy = x + y;</span><br><span class="line">xytype ab = a + b;</span><br></pre></td></tr></table></figure>
<p>为确定类型，编译器必须遍历一个核对表：</p>
<ol>
<li>如果expression是一个没有用括号括起的标识符：<code>decltype (x) y</code>，则var的类型与该标识符的类型相同，包括const等限定符；</li>
<li>如果expression是一个函数调用，则var的类型与函数的返回值类型相同；</li>
<li>如果expression是一个用括号括起的左值，则var为指向其类型的引用：<code>decltype ((x)) y</code>。括号并不会改变表达式的值和左值性；</li>
<li>如果前面的条件都不满足，则var的类型与expression的类型相同。</li>
</ol>
<p>decltype不能解决函数返回值类型的问题，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">?type? func(T1 &amp; a, T2 &amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">// a + b类型不确定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(a+b) func(T1 &amp;, T2 &amp;);  <span class="comment">// a+b未定义</span></span><br></pre></td></tr></table></figure>
<p>使用C++ 11后置返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">float</span> y)</span></span>;  <span class="comment">// 原来的函数定义方式</span></span><br><span class="line"></span><br><span class="line">auto func(int x, float y) -&gt; double;  // -&gt;double 被称为后置返回类型，其中auto是一个占位符，表示后置返回类型提供的类型</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意函数参数列表中的形参名a、b不能省略</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto func(T1 &amp; a, T2 &amp; b) -&gt; decltype(a+b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">// decltype(a+b)类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>register关键字：</p>
<p>关键字register最初是由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量，旨在提高访问变量的速度。</p>
<p>在C++ 11之前，这个关键字在C++中的用法始终未变。在C++ 11中，register关键字只是显式地指出变量是自动的，与C语言中的auto功能一致。</p>
</li>
<li><p>volatile关键字：</p>
<p>该关键字的作用是为了改善编译器的优化能力。将变量声明为volatile，相当于告诉编译器，不要进行这种优化。</p>
</li>
<li><p>mutable关键字：</p>
<p>即使结构（或类）变量为const，其某个成员也可以被修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> accesses;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3><span id="16-类型转换">16. 类型转换</span></h3><ol>
<li><p>初始化和赋值时进行的转换：</p>
<table>
<thead>
<tr>
<th align="center">转换</th>
<th align="center">潜在的问题</th>
</tr>
</thead>
<tbody><tr>
<td align="center">将较大的浮点类型转换为较小的浮点类型，如将double转换为float</td>
<td align="center">精度（有效数位）降低，值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的</td>
</tr>
<tr>
<td align="center">将浮点类型转换为整型</td>
<td align="center">小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的</td>
</tr>
<tr>
<td align="center">将较大的整型转换为较小的整型，如将long转换为short</td>
<td align="center">原来的值可能超出目标的取值范围，通常只复制右边的字节</td>
</tr>
</tbody></table>
</li>
<li><p>以列表初始化<code>&#123;&#125;</code>方式初始化时进行的转换（C++ 11）。列表初始化不允许缩窄，即变量的类型无法表示赋给它的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">66</span>;</span><br><span class="line"><span class="keyword">char</span> c = &#123;x&#125;;  <span class="comment">// 不允许，x是一个变量，可能表示一个很大的值</span></span><br><span class="line"><span class="keyword">char</span> c = x;  <span class="comment">// 允许</span></span><br></pre></td></tr></table></figure></li>
<li><p>表达式中的转换：</p>
<ol>
<li>整型提升：C++将表达式中的bool，char，unsigned char，signed char和short值转换为int。如果short比int短，则unsigned short类型将被转换为int；如果两种类型的长度相同，则unsigned short类型将被转换为unsigned int。</li>
<li>当运算涉及两种类型时，较小的类型将被转换为较大的类型。</li>
</ol>
<p>C++ 11校验表：</p>
<pre><code>1. 如果有一个操作数的类型是long double，则将另一个操作数转换为long double；
2. 否则，如果有一个操作数的类型是double，则将另一个操作数转换为double；
3. 否则，如果有一个操作数的类型是float，则将另一个操作数转换为float；
4. 否则，说明操作数都是整型，因此执行整型提升；
5. 在这种情况下，如果两个操作数都是有符号或者无符号的，且其中一个操作数的级别比另一个低，则转换为级别高的类型；
6. 如果一个操作数为有符号的，另一个操作数为无符号的，且无符号操作数的级别比有符号操作数高，则将有符号操作数转换为无符号操作数所属的类型；
7. 否则，如果有符号类型可表示无符号类型的所有可能取值，则将无符号操作数转换为有符号操作数所属的类型；
8. 否则，将两个操作数都转换为有符号类型的无符号版本。
</code></pre>
</li>
<li><p>强制类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">long</span>) thorn;  <span class="comment">// C语言格式</span></span><br><span class="line"><span class="keyword">long</span> (thorn);  <span class="comment">// C++语言格式</span></span><br><span class="line"></span><br><span class="line">(type) value;  <span class="comment">// C语言格式</span></span><br><span class="line">type (value);  <span class="comment">// C++语言格式</span></span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3><span id="17-数组的替代品">17. 数组的替代品</span></h3><ol>
<li><p><code>vector</code>和<code>array</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;typeName&gt; <span class="title">vt</span><span class="params">(n_elem)</span></span>; <span class="comment">// vector类位于名称空间std中，且使用vector类需包含头文件`vector`</span></span><br><span class="line"><span class="comment">// array</span></span><br><span class="line"><span class="built_in">array</span>&lt;typeName, n_elem&gt; arr;  <span class="comment">// array类位于名称空间std中，且使用array类需包含头文件`array`，n_elem必须是常量。使用栈，但是比数组更方便，安全</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">float</span>, 4&gt; arr = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;  <span class="comment">// array初始化</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="built_in">string</span>, 4&gt; arr;  <span class="comment">// 元素可以是类对象</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>valarray</code>：</p>
<p><code>valarray</code>类是由头文件<code>valarray</code>支持的，这个类用于处理数值，它支持诸如将数组中所有元素的值相加以及在数组中找出最大值和最小值等操作，它是一个模板类，能够处理不同的数据类型。基本用法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> gpa[<span class="number">5</span>] = &#123;<span class="number">3.1</span>, <span class="number">3.5</span>, <span class="number">3.8</span>, <span class="number">2.9</span>, <span class="number">3.3</span>&#125;;</span><br><span class="line">valarray&lt;<span class="keyword">double</span>&gt; v1;  <span class="comment">// an array of double, size 0</span></span><br><span class="line"><span class="function">valarray&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">8</span>)</span></span>;  <span class="comment">// an array of 8 int elements</span></span><br><span class="line"><span class="function">valarray&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">8</span>)</span></span>;  <span class="comment">// an array of int elements, each set to 10</span></span><br><span class="line"><span class="function">valarray&lt;<span class="keyword">double</span>&gt; <span class="title">v4</span><span class="params">(gpa, <span class="number">4</span>)</span></span>;  <span class="comment">// an array of 4 elements, initialized to the first 4 elements of gpa</span></span><br><span class="line"></span><br><span class="line">valarray&lt;<span class="keyword">int</span>&gt; v5 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// C++ 11</span></span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3><span id="18-流程控制">18. 流程控制</span></h3><ol>
<li><p>C++常用的方式是，在for、if、while等流程控制关键字与括号之间加上一个空格，而省略函数名与括号之间的空格；</p>
</li>
<li><p>在for-init-statement中声明的变量，在程序离开循环后消失；</p>
</li>
<li><p>在语句块中定义一个新的变量，则仅当程序执行该语句块中的语句时，该变量才存在。执行完该语句块后，变量将被释放；</p>
</li>
<li><p><code>for (; ;)</code>，当省略for循环中的测试表达式时，测试结果将为true，因此循环将一直运行下去；</p>
</li>
<li><p>基于范围的for循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> x : prices)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数组的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> &amp;x : prices)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合使用for循环和初始化列表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3><span id="19-递增和递减运算符">19. 递增和递减运算符</span></h3><ol>
<li><p>不要在同一条语句对同一个值递增或递减多次，对于这种语句，C++没有定义正确的行为。这种语句在不同的系统上将生成不同的结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = (<span class="number">4</span> + x++) + (<span class="number">6</span> + x++);</span><br></pre></td></tr></table></figure>
<p>表达式中<code>4+x++</code>不是一个完整表达式，因此，C++不保证<code>x</code>的值在计算子表达式<code>4+x++</code>后立刻增加1。在这个例子中，整条赋值语句是一个完整表达式，而分号标示了顺序点，因此C++只保证程序执行到下一条语句之前，<code>x</code>的值将被递增两次。C++没有规定是在计算每个子表达式之后将x的值递增，还是在整个表达式计算完毕后才将<code>x</code>的值递增。</p>
</li>
<li><p>前缀递增、前缀递减和解除引用运算符的优先级相同，以从右到左的方式进行结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式进行结合。</p>
</li>
</ol>
<h3><span id="20-逗号运算符">20. 逗号运算符</span></h3><ol>
<li>用于将多个表达式合并为一个：<code>++j, --i</code>；</li>
<li><code>int i, j;</code>声明变量时的逗号只是分隔符，不是逗号运算符；</li>
<li><code>i = 20, j = 20 * i;</code>，逗号表达式确保先计算第一个表达式，然后计算第二个表达式；</li>
<li>C++规定，逗号表达式的值是最后一个部分的值；</li>
<li>逗号运算符的优先级是所有运算符中最低的一个。因此<code>cats = 17, 240</code>将被解释为<code>(cats = 17), 240</code>。</li>
</ol>
<h3><span id="21-关系运算符">21. 关系运算符</span></h3><p>关系运算符的优先级比算术运算符低。</p>
<h3><span id="22-获取时间">22. 获取时间</span></h3><p><code>ctime</code>头文件提供了<code>CLOCKS_PER_SEC</code>常量，可以得到以时钟为单位的时间；<code>clock()</code>函数可用于获取当前系统时间。</p>
<h3><span id="24-类型别名">24. 类型别名</span></h3><ol>
<li><p>使用预处理器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> main mian  <span class="comment">// 艹</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有时候不适合使用#define</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLOAT_POINTER float *</span></span><br><span class="line">FLOAT_POINTER pa, pb;  <span class="comment">// pa是float *类型，而pb是float类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用typedef关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> typeName aliasName;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3><span id="25-输入重定向">25. 输入重定向</span></h3><p>假设在Windows系统中有一个名为gofish.exe的可执行程序和一个名为fishtale的文本文件，则可以在命令提示符模式下输入下面的命令：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gofish.exe &lt; fishtale</span><br></pre></td></tr></table></figure>
<p>这样，程序将从fishtale文件获取输入。</p>
<h3><span id="26-逻辑运算符">26. 逻辑运算符</span></h3><ol>
<li>由于<code>||</code>和<code>&amp;&amp;</code>的优先级比关系运算符低，因此不需要在这些表达式中使用括号，如<code>5 &gt; 3 || 5 &gt; 10</code>；</li>
<li><code>&amp;&amp;</code>的优先级高于<code>||</code>，<code>!</code>的优先级高于所有关系运算符和算术运算符；</li>
<li>C++规定，<code>||</code>和<code>&amp;&amp;</code>运算符是一个顺序点。也就是说先修改左侧的值，再对右侧的值进行判定。如<code>i++ &lt; 6 || i == j</code>；</li>
<li>C++确保程序从左到右进行计算逻辑表达式，并在知道答案后立刻停止（可以通过编写一个返回值为bool类型的函数进行验证）。</li>
</ol>
<h3><span id="27-文件输入输出">27. 文件输入输出</span></h3><ol>
<li>文件输出<ol>
<li>包含头文件fstream；</li>
<li>创建一个ofstream对象；</li>
<li>将该ofstream对象同一个文件关联起来（open函数）；</li>
<li>像使用cout一样使用该ofstream对象；</li>
<li>调用close函数关闭文件。</li>
</ol>
</li>
<li>文件输入<ol>
<li>包含头文件fstream；</li>
<li>创建一个ifstream对象；</li>
<li>将该ifstream对象同一个文件关联起来（open函数）；</li>
<li>使用该ifstream对象的<code>is_open</code>函数判断文件是否成功打开；</li>
<li>像使用cin一样使用该ifstream对象；</li>
<li>调用close函数关闭文件。</li>
</ol>
</li>
</ol>
<h3><span id="28-变量类型-作用域与链接性">28. 变量类型、作用域与链接性</span></h3><ol>
<li><p>自动变量</p>
</li>
<li><p>静态持续变量</p>
<ol>
<li>链接性为外部的静态持续变量（如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义，但在使用该变量的其他所有文件中，都必须使用关键字extern声明它，且不进行初始化，否则，声明将变为定义，导致分配存储空间）；</li>
<li>链接性为内部的静态持续变量（代码块外加static关键字，将屏蔽其他文件中的外部变量，作用域解析运算符<code>::</code>用于变量名前面，可以解除局部变量对全局变量的屏蔽作用）；</li>
<li>无链接性的静态持续变量（代码块内加static关键字，程序只进行一次初始化）</li>
</ol>
</li>
<li><p>动态内存分配</p>
<ol>
<li><p>使用new运算符的初始化：</p>
<p>在C++98中，使用括号括起的初始值进行初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt = <span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>初始化结构或者数组，需要使用大括号的列表初始化，要求编译器支持C++ 11</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">where</span> &#123;</span><span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> z&#125;;</span><br><span class="line">where * point = <span class="keyword">new</span> where &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * ar = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> * pt = <span class="keyword">new</span> <span class="keyword">int</span> &#123;<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>分配函数与释放函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配函数，new和new[]分别调用如下函数：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span></span>;  <span class="comment">// std::size_t是一个typedef</span></span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">// 被转换为int * pi = new(sizeof(int));</span></span><br><span class="line"><span class="keyword">int</span> * pa = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];  <span class="comment">// 被转换为int * pa = new(40 * sizeof(int));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放函数，delete和delete[]分别调用如下函数：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pi;  <span class="comment">// 被转换为delete(pi);</span></span><br></pre></td></tr></table></figure>
<p>可为new和delete提供替换函数，根据需要对其进行定制。可定义作用域为类的替换函数，并对其进行定制，以满足该类的内存分配需求，定制之后使用new运算符时，将调用自定义的new函数。</p>
</li>
<li><p>定位new运算符：</p>
<p>定位new运算符是new运算符的一个变体。定位new运算符可以在特定位置创建对象。要使用定位new特性，需要包含头文件new。使用定位new运算符时，变量后面可以有方括号，也可以没有。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer1[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">char</span> buffer2[<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line">where * pt_buffer1 = <span class="keyword">new</span> (buffer1) where;  <span class="comment">// 把where结构体放置于buffer1中</span></span><br><span class="line"><span class="keyword">int</span> * pt_buffer2 = <span class="keyword">new</span> (buffer2) <span class="keyword">int</span> [<span class="number">20</span>];  <span class="comment">// 把int数组放置于buffer2中</span></span><br></pre></td></tr></table></figure>
<p>将定位new运算符用于类对象时，由于定位new运算符对于缓冲区的使用情况一无所知，所以如果使用了动态内存做缓冲区，当该缓冲区被<code>delete []</code>释放时（或常规缓冲区过期时），缓冲区中的对象并不会调用析构函数。对于定位new运算符创建的类对象，需要显式调用析构函数，且必须以后进先出的方式销毁对象，因为后创建的对象可能依赖于先创建的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">512</span>];</span><br><span class="line">Foo * foo = <span class="keyword">new</span> (buffer) Foo;</span><br><span class="line"><span class="comment">// do something with foo</span></span><br><span class="line">foo-&gt;~Foo();  <span class="comment">// 显式调用析构函数</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
<li><p>函数的链接性：</p>
<p>函数也有链接性，默认为外部的，在其中一个源文件中使用另一个源文件中定义的函数，可以在函数原型中使用关键字extern（这是可选的）。也可以使用static关键字将函数的链接性设置为内部的，必须同时在原型和函数定义中使用该关键字。内联函数不受单定义规则约束，因此内联函数的定义可以放在头文件中。</p>
</li>
<li><p>语言链接性：</p>
<p>链接程序寻找与C++函数调用匹配的函数时，使用的方法与C语言不同。但如果要在C++程序中使用C库中预编译的函数，可以这么做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">spiff</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// 使用C语言版本</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C++&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">spiff</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// 使用C++版本</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">spiff</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// 使用C++版本</span></span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3><span id="29-名称空间">29. 名称空间</span></h3><ol>
<li><p>名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。名称空间是开放的，即可以把新的名称加入到已有的名称空间中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Jack &#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="comment">// 名称空间嵌套</span></span><br><span class="line">    <span class="keyword">namespace</span> Jill &#123;</span><br><span class="line">        <span class="keyword">double</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往Jack中再添加变量y</span></span><br><span class="line"><span class="keyword">namespace</span> Jack &#123;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Jack;  <span class="comment">// using编译指令，与下面两行等价</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Jack;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Jill;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以给名称空间创建别名</span></span><br><span class="line"><span class="keyword">namespace</span> my_very_favorite_things &#123;...&#125;;</span><br><span class="line"><span class="keyword">namespace</span> mvft = my_very_favorite_things;</span><br><span class="line"><span class="keyword">using</span> mvft::name;  <span class="comment">// using声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 未命名的名称空间</span></span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ice;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于这种名称空间没有名称，因此不能显式地使用using编译指令或using声明，因此可以替代链接性为内部的持续变量。创建完未命名的名称空间后，直接会有使用完using编译指令的效果。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ice;  <span class="comment">// 与上述名称空间中的名称具有同样的链接性</span></span><br></pre></td></tr></table></figure></li>
<li><p>using声明和using编译指令：</p>
<p>using声明使特定的标识符可用，using编译指令使整个名称空间可用。</p>
<p>假设名称空间和声明区域定义了相同的名称。如果试图使用using声明将名称空间的名称导入该声明区域，则这两个名称会发生冲突，从而出错。如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">cout</span> = <span class="number">10</span>;  <span class="comment">// global cout</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  <span class="comment">// cout in std namespace</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">cout</span> = <span class="number">20</span>;  <span class="comment">// local cout</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>;  <span class="comment">// cout in namespace</span></span><br><span class="line">    ::<span class="built_in">cout</span>;  <span class="comment">// global cout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3><span id="30-对象和类">30. 对象和类</span></h3><ol>
<li><p>结构体与类的区别：结构体的默认访问类型是public，而类为private；</p>
</li>
<li><p>基类的引用可以指向派生类对象，而无需进行强制类型转换，且这种向上强制转换是可传递的。在函数按值传递中，如果形参为基类类型，实参为派生类类型，则只会把派生类中属于基类的部分传递给函数；</p>
</li>
<li><p>在默认情况下，将一个对象赋给同类型的另一个对象时，C++将源对象的每个数据成员的内容复制到目标对象中相应的数据成员中。（Q：如果是动态分配的内存，这种复制是否导致内存异常？A：这只是在默认的情况下）；</p>
</li>
<li><p>声明类只是描述了对象的形式，并没有创建对象。因此创建对象前，将没有用于存储值的空间（但是C++ 11提供了成员初始化）；</p>
</li>
<li><p>定义成员函数时，==通常==在独立的实现文件中编写，使用作用域解析运算符（::）来标识函数所属的类；</p>
</li>
<li><p>内联方法：定义位于类声明中的函数都将自动成为内联函数。类声明常将短小的成员函数作为内联函数。在类声明之外定义成员函数，只需在类实现部分中定义函数时使用inline限定符即可使其成为内联函数。内联函数要求在每个使用它们的文件中都对其进行定义，为确保内联定义对多文件程序中的所有文件都可用，最简便的方法是将内联定义放在定义类的头文件中（有些开发系统包含智能链接程序，允许将内联定义放在一个独立的实现文件中）；</p>
</li>
<li><p>构造函数的名称与类名相同。构造函数的原型和函数头没有返回值，但没有被声明为void类型。实际上，构造函数没有声明类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Stock(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">long</span>, <span class="keyword">double</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式调用构造函数</span></span><br><span class="line">Stock stock = Stock(<span class="string">&quot;World Cabbage&quot;</span>, <span class="number">250</span>, <span class="number">1.25</span>);</span><br><span class="line">Stock * pstock = <span class="keyword">new</span> Stock(<span class="string">&quot;Electroshock Games&quot;</span>, <span class="number">18</span>, <span class="number">19.0</span>);</span><br><span class="line"><span class="comment">// 隐式调用构造函数</span></span><br><span class="line"><span class="function">Stock <span class="title">garment</span><span class="params">(<span class="string">&quot;Furry Mason&quot;</span>, <span class="number">50</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一条语句是初始化，它创建有指定值的对象，可能会创建临时对象（也可能不会，取决于编译器）；第二条语句是赋值，会导致在赋值前创建一个临时变量。如果既可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化方式。通常这种方式的效率更高</span></span><br><span class="line">Stock stock = Stock(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">2</span>, <span class="number">2.0</span>);</span><br><span class="line">stock = Stock(<span class="string">&quot;Nifty Foods&quot;</span>, <span class="number">10</span>, <span class="number">50.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 11的列表初始化语法，参数列表将与某个构造函数的参数列表匹配</span></span><br><span class="line">Complex c1 = &#123;<span class="number">2.0</span>， <span class="number">3.0</span>&#125;;</span><br><span class="line"><span class="built_in">complex</span> c2&#123;&#125;;  <span class="comment">// 使用默认构造函数</span></span><br><span class="line">Complex pt = <span class="keyword">new</span> Complex &#123;<span class="number">2.0</span>, <span class="number">3.0</span>&#125;;  <span class="comment">// C++ 11列表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值</span></span><br><span class="line">Complex c = <span class="number">1.0</span>;  <span class="comment">// Classname object = value;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果方法通过计算得到一个新的类对象，则应考虑是否可以使用类的构造函数来完成这种工作，这样可以确保新的对象是按正确的方式创建的</span></span><br><span class="line"><span class="keyword">return</span> Vector(x, y);</span><br></pre></td></tr></table></figure>
<p>如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。然而，可以在一个构造函数中使用new初始化指针，而在另一个构造函数中将指针初始化为空（0或C++中的nullptr），因为delete或<code>delete []</code>可以用于空指针。</p>
</li>
<li><p>为了防止类成员与参数名相同，常见的做法是在数据成员中使用<code>m_</code>前缀，或在成员名中使用后缀<code>_</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_company;</span><br><span class="line">    lomg m_share;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> company_;</span><br><span class="line">    lomg share_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>默认构造函数：</p>
<p>默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。它是用于下面这种声明的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock fluffy_the_cat;</span><br></pre></td></tr></table></figure>
<p>如果没有提供任何构造函数，则C++将自动提供默认构造函数。它是默认构造函数的隐式版本，不做任何工作，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock::Stock() &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>当且仅当没有自定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后，必须为它提供默认构造函数，否则下面的声明将出错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock stock;</span><br></pre></td></tr></table></figure>
<p>创建默认构造函数的方式有两种，由于只能有一个默认构造函数，因此不要同时采用这两种方式：</p>
<ol>
<li><p>使用默认参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock::Stock(<span class="keyword">const</span> <span class="built_in">string</span> &amp; co = <span class="string">&quot;Error&quot;</span>, <span class="keyword">int</span> n = <span class="number">0</span>, doouble pr = <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>使用函数重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock::Stock() &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>使用默认构造函数初始化对象：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stock first = Stock();  <span class="comment">// 显式调用默认构造函数</span></span><br><span class="line">Stock * first = <span class="keyword">new</span> Stock;  <span class="comment">// 隐式调用默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">Stock <span class="title">first</span><span class="params">()</span></span>;  <span class="comment">// 声明函数，返回值为Stock类型</span></span><br><span class="line">Stock second;  <span class="comment">// 隐式调用默认构造函数</span></span><br></pre></td></tr></table></figure></li>
<li><p>复制构造函数：</p>
<ol>
<li><p>每当程序生成了对象副本，如在函数按对象值传参（或函数返回对象）以及声明对象时赋值的时候，不会调用构造函数生成新的对象，而是调用了复制构造函数。当使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数，默认的复制构造函数逐个复制非静态成员，如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。复制构造函数的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo(<span class="keyword">const</span> Foo &amp;);</span><br><span class="line"></span><br><span class="line">Foo foo1;  <span class="comment">// 对象1</span></span><br><span class="line">Foo foo2 = foo1;  <span class="comment">// 调用复制构造函数</span></span><br><span class="line"><span class="function">Foo <span class="title">foo3</span><span class="params">(foo1)</span></span>;  <span class="comment">// 调用复制构造函数</span></span><br><span class="line">Foo foo4 = Foo(foo1);  <span class="comment">// 调用复制构造函数</span></span><br><span class="line">Foo * foo5 = <span class="keyword">new</span> Foo(foo1);  <span class="comment">// 调用复制构造函数</span></span><br></pre></td></tr></table></figure>
<p>由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。</p>
<p>如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。</p>
</li>
<li><p>警惕复制构造函数和重载赋值运算符函数：</p>
<p>如果对象成员引用了动态内存，则必须时刻警惕可能导致调用复制构造函数和重载赋值运算符函数的操作，如创建临时对象（函数按对象传参和返回对象，以及表达式计算存储中间值等），对象赋值等。一个有效的技巧时，将其定义为私有方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> Queue &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Queue &amp; q) &#123;<span class="keyword">return</span> *<span class="keyword">this</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做，可以避免编译器自动生成默认复制构造函数和重载赋值运算符函数，且因为这些方法是私有的，所以在类外编译器将禁止需要调用复制构造函数和重载赋值运算符函数的操作，但仍需警惕在类内执行这些操作，如类方法中返回对象仍无法避免的会创建临时变量。</p>
</li>
</ol>
</li>
<li><p>析构函数：</p>
<p>在类名前加上<code>~</code>，即成为析构函数的名称。析构函数跟构造函数一样，可以没有返回值和声明类型。析构函数没有参数。如果没有提供析构函数，编译器将隐式地声明一个默认析构函数，并在发现导致对象被删除的代码后，提供默认析构函数的定义。</p>
</li>
<li><p>const成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Complex c = Complex(<span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line">c.show();  <span class="comment">// 编译器报错，因为show函数的代码可能会修改c对象的成员，但是如果在析构函数中调用不会报错（不知道是不是个bug）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将const关键字放在函数的括号后面，保证函数不会修改调用对象，只要类方法不修改调用对象，就应将其声明为const</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complex::show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>this指针：</p>
<p>this指针指向用来调用成员函数的对象，<code>*this</code>表示调用成员函数的对象。对象成员<code>x</code>只不过是<code>this-&gt;x</code>的简写。</p>
</li>
<li><p>静态类成员：</p>
<p>静态类成员有一个特点：无论创建了多少个对象，程序都将只创建一个静态变量的副本，也就是说，类的所有对象共享同一个静态成员。不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。对于静态类成员，可以在类声明之外使用单独的语句来初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> mode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Foo::mode = <span class="number">0</span>;  <span class="comment">// 静态类成员初始化，初始化语句指出了类型，并使用了作用域解析运算符，但没有使用关键字static</span></span><br></pre></td></tr></table></figure>
<p>初始化是在方法文件中进行的，不能在声明文件中进行初始化。这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中，导致出现多个初始化语句副本，引发错误。</p>
<p>静态数据成员在类中声明，在包含类方法的文件中进行初始化，但如果静态成员是const整数类型或枚举型，则可以在类声明中初始化。静态数据成员初始化时使用作用域解析运算符来指出静态成员所属的类。</p>
</li>
<li><p>静态类成员函数：</p>
<p>静态类成员函数的声明必须包含关键字static，但如果函数定义是独立的，则其中不能包含关键字static。静态成员函数不能使用this指针。如果静态成员函数是在公有部分声明的，则可以使用类名和作用域解析运算符来调用它。由于静态成员函数不与特定对象相关联，因此只能使用静态数据成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStatus</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
<li><p>作用域为类的常量：</p>
<ol>
<li><p>可以用枚举为整型常量提供作用域为整个类的符号名称：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>Months = <span class="number">12</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，这种方式声明枚举并不会创建类数据成员。也就是说，所有对象中都不包含枚举。另外，Months只是一个符号名称，在作用域为整个类的代码中遇到它时，编译器将用12替换它。</p>
<p>在类声明中声明的结构、类或枚举被称为是被嵌套在类中，其作用域为整个类。这种声明不会创建数据对象，而只是指定了可以在类中使用的类型。如果声明是在类的私有部分进行的，则只能在这个类使用被声明的类型；如果声明是在公有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类型。</p>
</li>
<li><p>使用static关键字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该常量与其他静态变量存储在一起，而不是存储在对象中。因此，只有一个Months常量，被所有Color对象共享。在C++98中，只能使用这种技术声明值为整数或枚举的静态常量，而不能存储double常量，C++ 11消除了这种限制。</p>
</li>
</ol>
</li>
<li><p>成员初始化列表：</p>
<p>对于const数据成员，必须在执行到构造函数体之前，即创建对象时进行初始化。C++提供了成员初始化列表语法来完成数据成员的初始化工作。成员初始化列表由逗号分隔的初始化列表组成（前面带冒号）。它位于参数列表的右括号之后，函数体左括号之前。通常，初值可以是常量或构造函数的参数列表中的参数，也可以是表达式和函数调用。这种方式并不限于初始化常量。只有构造函数可以使用这种语法，对于const类成员和被声明为引用的类成员，也必须使用这种语法。对于本身就是类对象的成员来说，使用成员初始化列表的效率更高。</p>
<p>如果Classy是一个类，而mem1、mem2和mem3都是这个类的数据成员，则初始化语法规则如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Classy::Classy(<span class="keyword">int</span> n, <span class="keyword">int</span> m) : mem1(n), mem2(m), mem3(n * m + <span class="number">2</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>初始化列表中的每一项都调用与之匹配的构造函数，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student(<span class="keyword">const</span> <span class="keyword">char</span> * str, <span class="keyword">const</span> <span class="keyword">double</span> * pd, <span class="keyword">int</span> n) : name(str), scores(pd, n) &#123;&#125;</span><br><span class="line"><span class="comment">// 这里scores是valarray对象，scores(pd, n)将调用valarray(const double *, int)构造函数</span></span><br></pre></td></tr></table></figure>


<p>数据成员的被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关。在类中声明函数的时候可以不使用成员初始化列表语法，然后在定义时再进行添加。</p>
<p><strong>C++ 11的类内初始化</strong>：</p>
<p>C++ 11允许以更直观的方式进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mem1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mem2 = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这与在构造函数中使用成员初始化列表等价：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Classy::Classy() : mem1(<span class="number">10</span>), mem2(<span class="number">20</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用了使用成员初始化列表的构造函数，则列表参数将覆盖类内初始化的默认初始值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Classy::Classy(<span class="keyword">int</span> n) : mem1(n) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，构造函数将使用n来初始mem1，但mem2仍被设置为20。</p>
</li>
<li><p>作用域内枚举：</p>
<p>C++ 11提供了一种新枚举，其枚举量的作用域为类。可以避免两个枚举定义中的枚举量可能发生的冲突。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">egg</span> &#123;</span>Small, Medium, Large, Jumbo&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">t_shirt</span> &#123;</span>Small, Medium, Large, Xlarge&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以用关键字struct代替class。需要使用枚举名来限定枚举量，如<code>t_shirt::Small</code>；</p>
<p>常规枚举将自动转换为整型，如将其赋给int变量或用于比较表达式时，作用域内枚举不能隐式地转换为整型，但可以进行强制类型转换；</p>
<p>枚举用某种底层整型类型表示，在C++98中，如何选择取决于实现，因此包含枚举的结构的长度可能随系统而异。对于作用域内枚举，C++ 11消除了这种依赖型。默认情况下，C++ 11作用域内枚举的底层类型为int，另外，还可以指定底层整型类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> :</span> <span class="keyword">short</span> pizza &#123;Small, Medium, Large, Xlarge&#125;;  <span class="comment">// 测试不通过</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">pizza</span> :</span> <span class="keyword">short</span> &#123;Small, Medium, Large, Xlarge&#125;;  <span class="comment">// 测试通过</span></span><br></pre></td></tr></table></figure></li>
<li><p>运算符重载：</p>
<ol>
<li><p>重载运算符函数的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operatorop(argument-<span class="built_in">list</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当重载运算符函数作为类成员函数时（非友元函数），将通过对象调用；当重载运算符函数作为非成员函数时，运算符表达式左边的操作数对应于运算符函数的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数</span></span><br></pre></td></tr></table></figure></li>
<li><p>op必须是有效的C++运算符，不能虚构一个新的符号，例如不能有<code>operator@()</code>这样的函数。重载运算符与原来的原来的运算符具有相同的优先级；</p>
</li>
<li><p>为了区分<code>++</code>运算符的前缀版本和后缀版本，C++将<code>operator++()</code>作为前缀版本，将<code>operator++(int)</code>作为后缀版本，其中的参数永远也不会用到，所以不必指定其名称。</p>
</li>
<li><p>可以像调用<code>Sum()</code>等普通成员函数那样来调用<code>operator+()</code>等方法；</p>
</li>
<li><p>在运算符表示法中，运算符左侧的对象是调用对象，运算符右边的对象是作为参数被传递的对象；</p>
</li>
<li><p>因为运算符重载是通过函数来实现的，所以只要运算符函数的特征标不同，使用的运算符与相应的内置C++运算符相同，就可以多次重载同一个运算符，如减法运算符<code>-</code>和负号运算符<code>-</code>；</p>
</li>
<li><p>多对象进行运算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t4 = t1 + t2 + t3;</span><br><span class="line"><span class="comment">// 将被转换为如下函数调用</span></span><br><span class="line">t4 = t1.<span class="keyword">operator</span>+(t2.<span class="keyword">operator</span>+(t3));</span><br></pre></td></tr></table></figure></li>
<li><p>重载赋值运算符：</p>
<p>赋值运算符的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class_name &amp; Class_name::<span class="keyword">operator</span>=(<span class="keyword">const</span> Class_name &amp;);</span><br></pre></td></tr></table></figure>
<p>使用赋值运算符应注意的点：</p>
<ul>
<li>由于目标对象可能引用了以前分配的数据，所以函数应使用delete来释放这些数据；</li>
<li>函数应当避免对象给自身赋值，否则，给对象重新赋值前，释放内存的操作可能删除对象的内容；</li>
<li>函数返回一个指向调用对象的引用，因此可以连续进行赋值。</li>
</ul>
<p>一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Foo &amp; Foo::<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo &amp; foo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;foo)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] str;  <span class="comment">// 必须确保str是初始化过了的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 赋值其他内容 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>重载限制：</p>
<ol>
<li>使用运算符时不能违反运算符原来的句法规则。例如，不能将求模运算符号（%）重载成只使用一个操作数的运算符；</li>
<li>重载的运算符必须至少有一个操作数是用户自定义的类型；</li>
<li>不能创建新运算符，例如，不能定义<code>operator**()</code>函数来表示求幂；</li>
<li>不能重载下面的运算符：<ul>
<li><code>sizeof</code></li>
<li><code>.</code>成员运算符</li>
<li><code>::</code>作用域解析运算符</li>
<li><code>?:</code>条件运算符</li>
<li><code>typeid</code>一个RTTI运算符</li>
<li><code>const_cast</code>强制类型转换运算符</li>
<li><code>dynamic_cast</code>强制类型转换运算符</li>
<li><code>reinterpret_cast</code>强制类型转换运算符</li>
<li><code>static_cast</code>强制类型转换运算符</li>
</ul>
</li>
</ol>
<ol>
<li><p>友元有3种：</p>
<ul>
<li>友元函数</li>
<li>友元类</li>
<li>友元成员函数</li>
</ul>
<p>通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。</p>
</li>
<li><p>非成员重载运算符函数可以解决操作数互换的问题，但是不能访问类的私有数据。如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以使用友元函数来反转操作数的顺序，也不一定需要友元函数，如果不访问私有成员，可以不是友元函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t)  <span class="comment">// 操作数互换(非友元函数)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t * m;  <span class="comment">// use t.operator*(m)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>如果一个函数是多个类的友元函数，则该函数可以同时访问这些类的私有成员。</p>
</li>
<li><p>创建友元函数</p>
<p>创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字<code>friend</code>。虽然该函数是在类声明中进行声明的，但它不是成员函数，因此不能使用成员运算符来调用，但该函数内可以使用类的私有成员。在函数定义中不要使用类名，如<code>Time::</code>限定符，且不要使用<code>friend</code>关键字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="keyword">double</span>, <span class="keyword">const</span> Time &amp;);  <span class="comment">// 类中声明</span></span><br><span class="line"></span><br><span class="line">Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t) </span><br><span class="line">&#123;</span><br><span class="line">    t.hours = <span class="number">3.0</span>;  <span class="comment">// 函数定义，可以访问类的私有成员</span></span><br><span class="line">    <span class="keyword">return</span> t * m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一般来说，要重载<code>&lt;&lt;</code>运算符来显示<code>c_name</code>的对象，可以使用一个友元函数，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> c_name &amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>派生类中的友元函数可以通过强制类型转换成基类对象引用，进而调用基类友元函数，提供了访问私有数据的可能性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> derived &amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; (<span class="keyword">const</span> base &amp;) obj;</span><br><span class="line">    os &lt;&lt; ...; <span class="comment">// derived members</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
</li>
<li><p>类的自动类型转换和强制类型转换：</p>
<ol>
<li><p>在C++中，接受一个参数的构造函数可以作为将类型与该参数相同的值转换为类的转换构造函数，但只有接受一个参数的构造函数才能作为转换函数（带默认参数的函数也可以），这一过程称为隐式转换，因为它是自动进行的，不需要显式强制类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Weight(<span class="keyword">double</span> w);  <span class="comment">// 构造函数</span></span><br><span class="line">Weight w;</span><br><span class="line">w = <span class="number">19.6</span>;  <span class="comment">// 使用构造函数将19.6转换为Weight对象</span></span><br><span class="line"></span><br><span class="line">Weight w = <span class="number">19.6</span>;  <span class="comment">// 当构造函数只接受一个参数时，可以使用这种格式来初始化类对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Star north;</span><br><span class="line">north = <span class="string">&quot;polaris&quot;</span>;  <span class="comment">// 调用Star::operator=(const Star *)函数，使用Star::Star(const char *)生成一个对象，该对象将被用作上述赋值运算符函数的参数</span></span><br></pre></td></tr></table></figure>
<p>函数原型化提供的参数匹配过程，允许使用<code>Weight(double)</code>构造函数来转换其他数值类型，如<code>int</code>类型。然而当且仅当转换不存在二义性时，才会进行这种二步转换。也就是说，如果这个类还定义了构造函数<code>Weight(long)</code>，则编译器将拒绝这些语句，因为调用存在二义性。</p>
</li>
<li><p>使用隐式转换的情况有：</p>
<ul>
<li>将对象初始化为如<code>double</code>类型的值时；</li>
<li>将如<code>double</code>类型的值赋给对象时；</li>
<li>将如<code>double</code>类型的值传递给接受类对象参数的函数时；</li>
<li>返回值声明为类对象的函数试图返回如<code>double</code>类型的值时；</li>
<li>在上述任意一种情况下，使用可转换为如<code>double</code>类型的内置类型时（比如说使用<code>int</code>类型数据初始化）。</li>
</ul>
</li>
<li><p>C++新增了关键字<code>explicit</code>，用于关闭上述自动转换的特性，但仍然允许显式强制类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Weight</span><span class="params">(<span class="keyword">double</span> w)</span></span>;  <span class="comment">// 构造函数</span></span><br><span class="line">Weight w;</span><br><span class="line">w = Weight(<span class="number">19.6</span>);  <span class="comment">// ok，这不就是显式调用构造函数吗？</span></span><br><span class="line">w = (Weight) <span class="number">19.6</span>;  <span class="comment">// ok，旧格式</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建转换函数，将类对象转换为typeName类型，需要使用下面这种形式的转换函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typeName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = obj;  <span class="comment">// 隐式转换</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">int</span> (obj);  <span class="comment">// 强制类型转换</span></span><br><span class="line"><span class="keyword">int</span> a = (<span class="keyword">int</span>) obj;  <span class="comment">// 强制类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只定义了一种转换函数，如double转换函数，则下面的语句不会产生二义性，将使用double转换函数和二步转换</span></span><br><span class="line"><span class="keyword">long</span> var = obj;</span><br><span class="line"><span class="comment">// 如果同时定义了多种转换函数，则上述语句将产生二义性，编译器将报错。不过可以用显式强制类型转换来指出要使用哪个转换函数</span></span><br><span class="line"><span class="comment">// 如果参数类型不匹配，可能会产生二步转换。例如，在不使用explicit关键字的情况下只定义了int转换函数，但是强制转换为double类型，则先将obj转换为int值，再把int值转换为double值</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>转换函数必须是类方法；</li>
<li>转换函数不能指定返回类型；</li>
<li>转换函数不能有参数。</li>
</ul>
</li>
<li><p>在C++ 11中，允许将关键字<code>explicit</code>应用于转换函数，可以关闭隐式转换；</p>
</li>
<li><p>转换函数与友元函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设声明了友元重载加法运算符函数如下：</span></span><br><span class="line"><span class="keyword">friend</span> ClassName <span class="keyword">operator</span>+(<span class="keyword">const</span> ClassName &amp;, <span class="keyword">const</span> ClassName &amp;);</span><br><span class="line"><span class="comment">// 上述声明可能会调用转换构造函数（如传入double类型的值），导致运行性能下降。如果能指定函数参数为特定类型，则无需调用构造函数，运行速度更快些</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果定义了double转换构造函数，并且允许隐式转换，则下面的的代码将调用友元函数，将double的1.0传递给第一个参数，然后调用double转换构造函数生成一个Class对象，再执行对象相加操作。</span></span><br><span class="line">ClassName t = <span class="number">1.0</span> + obj;</span><br><span class="line"><span class="comment">// 如同时定义了operator double()转换函数，则上述代码将出现二义性，因为可以解释为将obj转换为double，再把两个double值相加</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果定义了隐式转换函数，但是没有定义友元运算符重载函数，则有时候对象会被隐式地转换。将重载定义为友元函数可以让程序更容易适应自动类型转换，原因在于，两个操作数都成为函数的参数，因此与函数原型匹配，从而调用重载函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName t = <span class="number">1.0</span> + obj;  <span class="comment">// obj可能被转换，如隐式转换为double</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
<li><p>类继承：</p>
<ol>
<li><p>公有派生：</p>
<p>使用公有派生，基类的公有成员将成为派生类的公有成员，基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建派生类对象时，程序首先创建基类对象。这意味着基类对象应当在程序进入派生类构造函数之前被创建，C++使用成员初始化列表语法来完成这种工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">derived::derived(type1 x, type2 y) : base(x, y) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>==除虚基类外，派生类只能将值传递回相邻的基类==，但后者可以使用相同的机制将信息传递给的其相邻的基类，依此类推。如果没有在成员初始化列表中提供基类构造函数，程序将使用默认的基类构造函数；C++ 11新增了一种能够继承构造函数的机制，默认不打开。</p>
<p>赋值运算符是不能被继承的，派生类继承的方法的特征标与基类完全相同，但赋值运算符的特征标随类而异，这是因为它包含一个类型为其所属类的形参。这种情况下，基类实现将被屏蔽。</p>
<p>派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。</p>
</li>
<li><p>派生类和基类之间的特殊关系：</p>
<p>基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。然而，基类指针或引用只能用于调用基类方法；不可以将基类对象和地址赋给派生类引用和指针；</p>
<p>引用兼容属性能够将基类对象初始化为派生类对象，这将调用隐式复制构造函数（如果没有定义的话）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Engineer e;</span><br><span class="line"><span class="function">Person <span class="title">p</span> <span class="params">(e)</span></span>;</span><br></pre></td></tr></table></figure>
<p>同样，可以将派生类对象赋给基类对象，这将调用隐式重载赋值运算符函数（如果没有定义的话）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Engineer e;</span><br><span class="line">Person p;</span><br><span class="line">p = e;</span><br></pre></td></tr></table></figure></li>
<li><p>多态公有继承：</p>
<p><strong>多态</strong>：方法的行为取决于调用该方法的对象。</p>
<p>如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。方法在基类中被声明为虚的后，它在派生类（包括从派生类派生出来的类）中将自动成为虚方法（派生链中所有函数）；</p>
<p>如果要在派生类中重新定义基类的方法，则在基类中将它设置为虚方法；否则，设置为非虚方法；然而，在派生类声明中使用关键字<code>virtual</code>来指出哪些函数是虚函数也不失为一个好办法（实际上在派生类中<code>virtual</code>可省略）。</p>
<p>如果没有使用关键字<code>virtual</code>，程序将根据引用类型或指针类型选择方法；如果使用了关键字<code>virtual</code>，程序将根据引用或指针指向的对象的类型来选择方法；</p>
<p>==使用基类指针指向派生类对象后，若没有使用<code>virtual</code>关键字，则<code>*object</code>将是基类对象，否则是派生类对象，即<code>typeid(*object).name()</code>将是基类类型，否则是派生类类型==；</p>
<p>在继承中允许派生类与基类出现同名函数或重载函数（此时将根据类型选择方法），但是非虚函数不具有多态特性；</p>
<p>如果方法重新进行了定义，那么在派生类中，使用作用域解析运算符<code>::</code>来调用基类方法，若直接调用，可能会导致递归；如果派生类中没有重新定义方法，则可以直接调用基类方法；</p>
<p>友元不能是虚函数，因为友元不是类成员，而只有类成员才能是虚函数；</p>
<p>如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本；</p>
<p>重新定义派生类中的方法并不是重载，无论参数列表是否相同，派生类的新方法将隐藏所有同名的基类方法。有两条经验规则：</p>
<p>第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变，因为允许返回值类型随类类型的变化而变化；</p>
<p>第二，如果基类声明被重载了，则应该在派生类中重新定义所有的基类版本。如果不需要修改，则新定义可以只调用基类版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Person <span class="title">getInfo</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;  <span class="comment">// Base class</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Engineer <span class="title">getInfo</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// Derived class</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Engineer <span class="title">getInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> Person::getInfo();&#125;  <span class="comment">// 重新定义的方法直接返回基类的实现</span></span><br><span class="line"></span><br><span class="line">Engineer::getInfo(<span class="number">5</span>);  <span class="comment">// 错误，重新定义的函数与基类原型不一致，将屏蔽基类的版本</span></span><br></pre></td></tr></table></figure></li>
<li><p>静态联编和动态联编：</p>
<p>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编；在编译过程中进行联编被称为静态联编，又称为早期联编；编译器生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编，又称为晚期联编。在C++中，动态联编与通过指针和引用调用方法相关；</p>
<p>虚函数的工作原理：通常，编译器处理虚函数的方法是，给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表，虚函数表存储了为类对象进行声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该虚函数表将保存原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到虚函数表中。</p>
<p>对使用了虚函数的类对象使用<code>sizeof</code>运算符，可以看到类对象使用了额外的存储空间，用于实现虚函数机制。</p>
</li>
<li><p>虚析构函数：</p>
<p>如果析构函数不是虚的，则当使用delete关键字释放基类指针指向的派生类对象所占用的内存时，将会调用基类的析构函数。如果析构函数是虚的，则调用的析构函数取决于指向的对象的类型，而不是指针的类型。对于虚析构函数，如果基类指针指向派生类对象，则释放内存时，先调用派生类的析构函数，再调用基类的析构函数；</p>
<p>析构函数应当是虚函数，除非类不做基类。</p>
<p>==即使虚构函数是纯虚函数，也必须进行实现==。</p>
</li>
<li><p>访问控制protected：</p>
<p>关键字<code>protected</code>与<code>private</code>相似，在类外只能用公有类成员来访问protected部分中的类成员。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。因此，对于外部世界来说，保护成员的行为与私有成员相似；但对于派生类来说，保护成员的行为与公有成员相似;</p>
<p>最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据。然而，对于成员函数来说，保护访问控制很有用，它让派生类能够访问类外不能使用的内部函数。</p>
</li>
<li><p>抽象基类ABC</p>
<p>为解决继承中出现的信息冗余，可以使用抽象基类。例如，从Ellipse和Circle类中抽象出它们的共性，将这些特性放到一个ABC中，然后从该ABC中派生出Circle和Ellipse类。这样，便可以使用基类指针数组同时管理Circle和Ellipse对象。</p>
<p>C++通过使用纯虚函数提供未实现的函数（实际上也可以实现虚函数，但是似乎没什么用），纯虚函数声明的结尾处为<code>=0</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;  <span class="comment">// a pure virtual function</span></span><br></pre></td></tr></table></figure>
<p>当类声明中包含纯虚函数时，不能创建该类的对象，只能用作基类。抽象类必须至少包含一个纯虚函数。</p>
</li>
</ol>
</li>
</ol>
<h3><span id="31-c中的代码重用">31. C++中的代码重用</span></h3><p>通常，包含、私有继承和保护继承用于实现has-a关系，即新的类将包含另一个类的对象。</p>
<p>大多数C++程序员倾向于使用包含，因为私有继承比较复杂，可能出现多个独立基类中包含同名方法或共享祖先等问题；使用包含可以包括多个同类的子对象，如3个string对象，而继承则只能使用一个string对象。如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承。</p>
<ol>
<li><p>私有继承：</p>
<p>使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们，它实现了has-a关系。</p>
<p>在类继承中，<code>private</code>是默认值，因此省略访问限定符也将导致私有继承：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> :</span> <span class="keyword">private</span> Person  <span class="comment">// private可省略</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用作用域解析运算法来调用基类的方法，如<code>Base::sum();</code>；但如果要使用基类对象本身，可以使用强制类型转换，将<code>Derived</code>对象转换为<code>Base</code>对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Base &amp; <span class="title">Derived::GetBase</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">const</span> <span class="built_in">string</span> &amp;) * <span class="keyword">this</span>;  <span class="comment">// 为避免调用构造函数创建新的对象，可使用强制类型转换来创建一个引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用类名显式地限定函数名不适合友元函数，这是因为友元不属于类。但是，可以通过显式地转换为基类来调用正确的函数，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> Base &amp; base)  <span class="comment">//  Base由string派生而来</span></span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; (<span class="keyword">const</span> <span class="built_in">string</span> &amp;) base &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类的引用不会自动转换为基类的引用，在私有继承中，未进行显式类型转换的派生类引用或指针，无法赋值给基类的引用或指针。</p>
</li>
<li><p>保护继承</p>
<p>保护继承是私有继承的变体。保护继承在列出基类时使用关键字<code>protected</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> :</span> <span class="keyword">protected</span> Person</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用保护继承时，基类的公有成员和保护成员都将称为派生类的保护成员。和私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的。当从派生类派生出另一个类时，私有继承和保护继承之间的主要区别便呈现出来了。使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的公有方法在派生类中将变成私有方法；使用保护继承时，基类的公有方法在第二代中将变成受保护的，因此第三代派生类可以使用它们。</p>
</li>
<li><p>使用using重新定义访问权限</p>
<p>可以使用using声明，指出派生类中可以使用的基类成员，即使采用的是私有派生：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> :</span> <span class="keyword">private</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Person::Name;  <span class="comment">// 使用using声明使得基类私有成员函数可用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，using声明只使用成员名，没有圆括号、函数特征标和返回类型，因此，对于<code>operator[]</code>函数（const和非const）都可用。using声明只适用于继承，不适用于包含。</p>
</li>
<li><p>多重继承</p>
<p>使用多个基类的继承被称为多重继承（Multiple Inheritance, MI）。</p>
<p>必须使用关键字来限定每一个基类，否则编译器将认为是私有派生：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PineApple</span> :</span> <span class="keyword">public</span> Pie, <span class="keyword">public</span> Apple &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>如果<code>Pie</code>和<code>Apple</code>都有一个共同的基类<code>Food</code>，那么<code>PineApple</code>类将包含两个<code>Food</code>组件，此时将派生类对象的地址赋给基类指针，将会出现二义性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PineApple pa;</span><br><span class="line">Food * pt = &amp;pa;  <span class="comment">// ambiguous</span></span><br></pre></td></tr></table></figure>
<p>通常，这种赋值将把基类指针设置为派生对象中基类对象的地址，但<code>pa</code>中包含两个<code>Food</code>对象，有两个地址可供选择，所以应使用类型转换来指定对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Food *pt = (Pie *)&amp;pa;  <span class="comment">// Food in Pie</span></span><br><span class="line">Food *pt = (Apple *)&amp;pa;  <span class="comment">// Food in Apple</span></span><br></pre></td></tr></table></figure>
<p>虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// virtual和public的次序无关紧要</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pie</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Food &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Food &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PineApple</span> :</span> <span class="keyword">public</span> Pie, <span class="keyword">public</span> Apple &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>现在<code>PineApple</code>对象只包含<code>Food</code>对象的一个副本，也因为只有一个副本，所以可以使用多态（没有使用虚基类之前，需要强制类型转换，所以多态只存在于上一层的继承中）。</p>
<p>如果使用虚基类，那么构造函数中派生类向基类逐级传递信息将不起作用（==除虚基类外，派生类只能将值传递回相邻的基类==），例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class PineApple(const Food &amp; f, int weight, int color) : Pie(f, weight), Apple(f, color)&#123;&#125;  // 存在缺陷</span><br></pre></td></tr></table></figure>
<p>C++在基类是虚的时，禁止信息通过中间类自动传递给基类。因此，上述构造函数将初始化成员<code>weight</code>和<code>color</code>，但是<code>f</code>参数中的信息将不会传递给子对象<code>Food</code>。然而，编译器必须在构造派生类对象之前构造基类对象组件，因此，在上述情况下，编译器将使用<code>Food</code>的默认构造函数。如果不希望使用默认构造函数来构造虚基类对象，则需要显式地调用所需的基类构造函数。因此，构造函数应该是这样的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class PineApple(const Food &amp; f, int weight, int color) : Food(f), Pie(f, weight), Apple(f, color)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对于虚基类，必须这样做，但对于非虚基类，则是非法的。如果类有间接虚基类，则除非只使用该虚基类的默认构造函数，否则必须显式地调用该虚基类的某个构造函数。</p>
<p>假如<code>PineApple</code>没有重新定义<code>Show</code>方法，则调用<code>PineApple::Show</code>时将出现二义性，可以通过作用域解析运算符来指定调用函数<code>pa.Pie::Show</code>。</p>
<p>总之，在祖先相同时，使用MI必须引入虚基类，并修改构造函数初始化列表的规则。另外，如果在编写这些类的时候没有考虑到MI，则还可能需要重新进行编写，例如，<code>Pie</code>和<code>Apple</code>中都有<code>Show</code>方法，且都调用了<code>Food</code>的<code>Show</code>方法，如果在<code>PineApple</code>类中要输出所有信息，可以先调用<code>Pie::Show</code>和<code>Apple::Show</code>，但是这样会导致<code>Food::Show</code>的重复调用。对此，一种方法是提供一个只显示<code>Food</code>组件的方法和一个只显示<code>Pie</code>组件和<code>Apple</code>组件的方法，然后在<code>PineApple::Show</code>方法中将组件组合起来。</p>
<p>当类通过多条虚途径和非虚途径继承某个特定的基类时，该类将包含一个表示所有的虚途径的基类子对象和分别表示各条非虚途径的多个基类子对象。假设类B被用作类C和D的虚基类，同时被用作类X和Y的非虚基类，而类M是从C、D、X和Y派生而来的。在这种情况下，类M从虚派生祖先（即类C和D）那里共继承了一个B类子对象，并从每一个非虚派生祖先（即类X和Y）分别继承了一个B类子对象。因此，它包含三个B类子对象。</p>
<p>如果使用虚基类，从不同的类那里继承了两个或多个同名成员（数据或者方法），则使用该成员名时不一定会导致二义性。在这种情况下，如果某个名称优先于其他所有名称，则使用它时，即使不使用限定符，也不会导致二义性。</p>
<p>优先的定义为：派生类中的名称优先于间接或祖先类中的相同名称，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">q</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">B::q</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In B::q()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">q</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">omg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">C::q</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In C::q()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C::omg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In C::omg()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">omg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">E::omg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In E::omg()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> :</span> <span class="keyword">public</span> D, <span class="keyword">public</span> E</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F f;</span><br><span class="line">    f.q();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类<code>C</code>中的<code>q()</code>定义优先于类<code>B</code>中的<code>q()</code>定义，因为类<code>C</code>是从类<code>B</code>派生而来的。因此，<code>F</code>中的方法可以使用<code>q()</code>来表示<code>C::q()</code>。另一方面，任何一个<code>omg()</code>定义都不优先于其他<code>omg()</code>定义，==因为<code>C</code>和<code>E</code>都不是对方的基类==，所以，在<code>F</code>中使用非限定的<code>omg()</code>将导致二义性。</p>
<p>==虚二义性规则与访问规则无关==，不能通过<code>private, public</code>等关键字修改虚二义性优先级规则。</p>
</li>
<li><p>类模板</p>
<p>采用模板时，将使用模板定义替换类声明，使用模板成员函数替换类的成员函数。和模板函数一样，模板类如下代码开头：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;  <span class="comment">// 较新的C++实现可以用typename代替class</span></span><br></pre></td></tr></table></figure>
<p>关键字<code>template</code>告诉编译器要定义一个模板。<code>Type</code>为泛型标识符，可以使用自己的泛型名代替<code>Type</code>。</p>
<p>以模板成员函数替换原有的类方法，每个函数都将以上述相同的模板声明打头，还需将成员函数的类限定符从<code>Class::</code>改为<code>Class&lt;Type&gt;::</code>，但是如果在类声明中定义了方法（内联定义），则可以省略模板前缀和类限定符。</p>
<p>==注意==：不能将模板函数放在独立的实现文件中（以前，C++标准确实提供了关键字<code>export</code>，能够将模板成员函数放在独立的实现文件中，但支持该关键字的编译器不多；C++ 11不再这样使用关键字<code>export</code>，而将其保留用于其他用途）。由于模板不是函数，它们不能单独编译。==模板必须与特定的模板实例化请求一起使用==。最简单的方法是将所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含该头文件。</p>
<p>==注意==：声明成员函数的返回类型时可以为<code>Class</code>，而实际的模板函数定义将类型定义为<code>Class&lt;Type&gt;</code>，前者是后者的缩写，但只能在类中使用。即可以在模板声明或模板函数定义内使用<code>Class</code>，但在类的外面，即指定返回类型或者使用作用域解析运算符时，必须使用完整的<code>Class&lt;Type&gt;</code>。==但是==，经试验，函数的参数类型，如复制构造函数与赋值运算符函数的参数<code>const Class &amp;</code>，在声明和定义时，可以不加<code>&lt;Type&gt;</code>。同时，<code>template &lt;class T&gt;</code>中泛型标识符只是一个占位符，对于不同的成员函数，可以使用不同的标识符。</p>
<p>非类型参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">n</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>int</code>指出<code>n</code>的类型为<code>int</code>，这种参数（指定特殊的类型而不是用作泛型名）称为非类型或者表达式参数。假设有如下声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName&lt;<span class="keyword">double</span>, <span class="number">12</span>&gt; obj;</span><br></pre></td></tr></table></figure>
<p>将导致编译器定义名为<code>ClassName&lt;double, 12&gt;</code>的类。</p>
<p>==限制==：表达式参数可以使整型、枚举、引用或指针。因此<code>double m</code>不合法，<code>double &amp; rn</code>和<code>double * pn</code>是合法的。模板代码不能修改参数的值，也不能使用参数的地址，所以，不能使用诸如<code>n++</code>或<code>&amp;n</code>等表达式。另外，实例化模板是，用作表达式参数的值必须是==常量表达式==。</p>
<p>==优势==：表达式参数使用的是为自动变量维护的内存栈，执行速度更快，适用于使用了很多小型数组的情况。</p>
<p>==缺点==：表达式参数不同时，将生成独立的类声明。</p>
<p>模板的多功能性：可以将用于常规类的技术用于模板类。模板类可用作基类，也可用作组件类，还可用作其他模板的类型参数，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array &lt; Stack&lt;<span class="keyword">int</span>&gt; &gt; asi;  <span class="comment">// an array of stacks of int</span></span><br></pre></td></tr></table></figure>
<p>在C++ 98中要求使用至少一个空白字符将两个<code>&gt;</code>符号分开，以免与运算符<code>&gt;&gt;</code>混淆，C++ 11则不做要求。</p>
<p>==递归使用模板==：<code>Array&lt;Array&lt;double, 5&gt;, 10&gt; twodee</code>，可用于构造多维数组。</p>
<p>==默认类型模板参数==：可以为类型参数提供默认值：<code>template &lt;class T1, class T2 = int&gt; class Topo &#123;...&#125;;</code>，如果省略<code>T2</code>的值，编译器将使用<code>int</code>。若所用模板参数都有默认参数，则可以这样定义对象<code>ClassName&lt;&gt; obj;</code>。==注意==：可以为类模板类型参数提供默认值，但是不能为函数模板参数提供默认值，因为隐式实例化将覆盖默认值。</p>
<p>==三种具体化==：</p>
<ol>
<li><p>隐式实例化：通过声明一个或多个类对象，指出所需类型，编译器使用同样模板生成具体的类定义，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; ar;  <span class="comment">// implicit instantiation</span></span><br></pre></td></tr></table></figure>
<p>编译器在需要对象之前，不会生成类的隐式实例化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; *pt;  <span class="comment">// a pointer, no object needed yet</span></span><br><span class="line">pt = <span class="keyword">new</span> Array&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt;;  <span class="comment">// now an object is needed</span></span><br></pre></td></tr></table></figure>
<p>第二条语句导致编译器生成类定义，并根据该定义创建一个对象。</p>
</li>
<li><p>显式实例化</p>
<p>当使用关键字<code>template</code>并指出所需类型来声明类时，编译器将生成类声明的显式实例化。声明必须位于模板定义的名称空间中。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;</span><span class="keyword">int</span>, <span class="number">10</span>&gt;;  <span class="comment">// generate Array&lt;int, 10&gt; class</span></span><br></pre></td></tr></table></figure>
<p>这里比函数模板多了关键字<code>class</code>，经测试<code>class</code>关键字可省略（<code>g++</code>不能省略，<code>cl</code>可省略）。虽然没有创建对象，编译器也将生成类声明（包括方法定义），和隐式实例化一样，也将根据同样模板（与下述显式具体化比较）来生成具体化。</p>
</li>
<li><p>显式具体化</p>
<p>显式具体化是特定类型（用于替换模板中的泛型）的定义。有时候，可能需要在为特殊类型实例化时，对模板进行修改（比如内置变量类型，如<code>char *</code>不支持的运算符等），使其行为不同。在这种情况下，可以创建显式具体化。</p>
<p>当具体化模板和通用模板都与实例化请求匹配时，编译器将使用具体化版本。</p>
<p>具体化类模板定义的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Classname</span>&lt;</span>specialized-type-name&gt; &#123;...&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>部分具体化</p>
<p>部分具体化可以给类型参数之一指定具体的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// general template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="comment">// explicit specialization</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> &lt;</span><span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;...&#125;;</span><br><span class="line"><span class="comment">// specialization with T2 set to int</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> &lt;</span>T1, <span class="keyword">int</span>&gt; &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>关键字<code>template</code>后面的<code>&lt;&gt;</code>声明的是没有被具体化的类型参数，如果指定所有类型，则<code>&lt;&gt;</code>内将为空，这将导致显式具体化。</p>
<p>如果有多个模板可供选择，编译器将使用具体化程度最高的模板。例如，给定上述三个模板，有以下使用情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; p1;  <span class="comment">// use general Pair template</span></span><br><span class="line">Pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; p2;  <span class="comment">// use Pair&lt;T1, int&gt; partial specialization</span></span><br><span class="line">Pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p3;  <span class="comment">// use Pair&lt;int, int&gt; explicit specialization</span></span><br></pre></td></tr></table></figure>
<p>也可以通过为指针提供特殊版本来部分具体化现有的模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  <span class="comment">// general version</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span>...&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 书上是这样写的，但是测试时编译不通过，为指针单独设计了一个语法确实有点恶心，不好记</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>*&gt;</span>  <span class="comment">// pointer partial specialization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span>...&#125;;  <span class="comment">// modified code</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样子写倒是可以</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &lt;</span><span class="class"><span class="keyword">class</span> <span class="title">T</span>*&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果提供的类型不是指针，则编译器将使用通用模板；如果提供但是指针，则编译器将使用指针具体化版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">char</span>&gt; obj;  <span class="comment">// use general Foo template, T is char</span></span><br><span class="line">Foo&lt;<span class="keyword">char</span> *&gt; pobj;  <span class="comment">// use Foo T* template, T is char</span></span><br></pre></td></tr></table></figure>
<p>第二个声明将使用具体化模板，将<code>T</code>转换为<code>char</code>（==不带<code>*</code>==）。</p>
<p>部分具体化特性使得能够设置各种限制，例如，给定以下声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// general template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>, <span class="keyword">class</span> <span class="title">T3</span>&gt;</span> Class Foo &#123;...&#125;;</span><br><span class="line"><span class="comment">// specialization with T3 set to T2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &lt;</span>T1, T2, T2&gt; &#123;...&#125;;</span><br><span class="line"><span class="comment">// specialization with T2 and T3 set to T1*</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span>  <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &lt;</span>T1, T1*, T1*&gt; &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述声明下，编译器将作出如下选择：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">int</span>, <span class="keyword">short</span>, <span class="keyword">char</span> *&gt; foo;  <span class="comment">// use general template</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>, <span class="keyword">short</span>&gt; foo;  <span class="comment">// use Foo&lt;T1, T2, T2&gt; template</span></span><br><span class="line">Foo&lt;<span class="keyword">char</span>, <span class="keyword">char</span> *, <span class="keyword">char</span> *&gt; foo;  <span class="comment">// use Foo&lt;T1, T1 *, T1 *&gt; template</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>==成员模板==：模板可用作结构、类或模板类的成员（函数不允许嵌套，类声明允许嵌套）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">beta</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> V&gt; <span class="comment">// nested template class member</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">hold</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        V val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        hold(V v = <span class="number">0</span>) : val(v) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">        <span class="function">V <span class="title">Value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    hold&lt;T&gt; q;   <span class="comment">// template object</span></span><br><span class="line">    hold&lt;<span class="keyword">int</span>&gt; n; <span class="comment">// template object</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    beta(T t, <span class="keyword">int</span> i) : q(t), n(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="comment">// template method</span></span><br><span class="line">    <span class="function">U <span class="title">blab</span><span class="params">(U u, T t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n.Value() + q.Value()) * u / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        q.show();</span><br><span class="line">        n.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>blab</code>方法的<code>U</code>类型由该方法被调用时的参数值显式确定，<code>T</code>类型由对象的实例化类型确定，它不是由函数调用设置的（这里是隐式实例化吗？）。</p>
<p>可以在<code>beta</code>类中声明<code>hold</code>类和<code>blab</code>方法，然后在<code>beta</code>模板外面进行定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">beta</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> V&gt; <span class="comment">// nested template class member</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">hold</span>;</span></span><br><span class="line"></span><br><span class="line">    hold&lt;T&gt; q;   <span class="comment">// template object</span></span><br><span class="line">    hold&lt;<span class="keyword">int</span>&gt; n; <span class="comment">// template object</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    beta(T t, <span class="keyword">int</span> i) : q(t), n(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="comment">// template method</span></span><br><span class="line">    <span class="function">U <span class="title">blab</span><span class="params">(U u, T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        q.show();</span><br><span class="line">        n.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member definition</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">beta</span>&lt;</span>T&gt;::hold</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    V val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    hold(V v = <span class="number">0</span>) : val(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function">V <span class="title">Value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member definition</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line">U beta&lt;T&gt;::blab(U u, T t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (n.Value() + q.Value()) * u / t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为模板是嵌套的，所以必须使用下面的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不能用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还必须使用作用域解析运算符<code>::</code>指出<code>hold</code>和<code>blab</code>是<code>beta&lt;T&gt;</code>类的成员。这里虽然<code>hold</code>类声明在<code>beta&lt;T&gt;</code>类的私有部分，但是依然可以在模板外面进行定义。</p>
<p>==将模板用作参数==：模板还可以包含本身就是模板的参数，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Things</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Things&lt;<span class="keyword">int</span>&gt; bar;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>模板参数是<code>template &lt;typename T&gt; class Things</code>，其中<code>template &lt;typename T&gt; class</code>是类型，<code>Things</code>是参数。使用<code>Foo</code>声明类对象时，模板参数必须是一个模板类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;Stack&gt; foo;  <span class="comment">// Stack must be a template class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span>...&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，<code>Things&lt;int&gt;</code>将会被实例化为<code>Stack&lt;int&gt;</code>。这里，<code>Things</code>被硬编码为<code>int</code>类型。</p>
<p>可以混合使用模板参数和常规参数，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Things</span>, <span class="title">typename</span> <span class="title">U</span>, <span class="title">typename</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Things&lt;U&gt; bar;  </span><br><span class="line">  Things&lt;V&gt; foo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，成员<code>bar</code>和<code>foo</code>可存储的数据类型为泛型，而不是像之前的硬编码。</p>
<p>==模板类和友元==：</p>
<ol>
<li><p>模板类的非模板友元函数</p>
<p>在模板类中将一个常规函数声明为友元：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasFriend</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span>;  <span class="comment">// friend to **all** HasFriend instantiations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元函数可以像类成员函数一样访问类的数据成员，假设要为友元函数提供模板类参数，可以用如下方式进行友元声明吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(HasFriend &amp;)</span></span>;  <span class="comment">// possible?</span></span><br></pre></td></tr></table></figure>

<p>答案是不可以。原因是不存在<code>HasFriend</code>这样的对象，而只有特定的具体化，如<code>HasFriend&lt;Short&gt;</code>。要提供模板类参数，必须指明具体化。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasFriend</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ct;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;T&gt; &amp;)</span></span>;  <span class="comment">// bound template friend</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// each specialization has its own static data member</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> HasFriend&lt;T&gt;::ct = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>注意，<code>report()</code>函数本身不是模板函数，而只是使用一个模板作参数。因此必须为要使用的友元定义显式具体化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="keyword">short</span>&gt; &amp;)</span> </span>&#123;...&#125;;  <span class="comment">// explicit specialization for short</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="keyword">int</span>&gt; &amp;)</span> </span>&#123;...&#125;;  <span class="comment">// explicit specialization for int</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>约束模板友元，即友元的类型取决于类被实例化时的类型</p>
<p>首先，在类的定义前面声明每个模板函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">reports</span><span class="params">(T &amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后，在类中再次将模板声明为友元：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasFriendT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> counts&lt;TT&gt;();</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> reports&lt;&gt;(HasFriendT&lt;TT&gt; &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述声明中的<code>&lt;&gt;</code>指出这是模板的具体化，对于<code>reports</code>，<code>&lt;&gt;</code>可以为空，因为可以从函数参数推断出模板类型<code>HasFriendT&lt;TT&gt;</code>，当然，也可以显式指出<code>friend void reports&lt;HasFriendT&lt;TT&gt;&gt;(HasFriendT&lt;TT&gt; &amp;)</code>。</p>
<p><code>counts()</code>函数没有参数，因此必须使用模板参数语法<code>&lt;TT&gt;</code>来指明其具体化。</p>
<p>泛型名<code>TT</code>和<code>T</code>只是占位符，因此也可以同名。</p>
<p>接着定义友元函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template friend functions definitions</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reports</span><span class="params">(T &amp;hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用友元函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count&lt;<span class="keyword">int</span>&gt;();  <span class="comment">// Q:此时实例化HasFriendT&lt;int&gt;了吗？A:实例化了。</span></span><br><span class="line">reports(obj);</span><br></pre></td></tr></table></figure>

<p>程序将包含多个<code>count()</code>函数，分别对于不同实例化的类类型的友元。同时，<code>count()</code>函数调用没有可被编译器用来推断出所需具体化的函数参数，所以这些调用使用语法<code>cout&lt;int&gt;</code>指明具体化，但是对于<code>reports()</code>调用，编译器可以从参数类型推断出要使用的具体化。</p>
</li>
<li><p>非约束模板友元，即友元的所有具体化都是类的每一个具体化的友元</p>
<p>通过在类内声明模板，可以创建非约束友元函数，即每个函数具体化都是每个类具体化的友元。对于非约束友元，友元模板类型参数与模板类类型参数是不同的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManyFriend</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> D&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">show</span> <span class="params">(C &amp;, D &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span> <span class="params">(C &amp;, D &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种形式的友元可以与任何类型匹配，包括<code>int</code>等内置参数。</p>
</li>
</ol>
<p>==模板别名==（C++ 11）：可以使用<code>typedef</code>为模板具体化指定别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Array&lt;<span class="keyword">double</span>, <span class="number">10</span>&gt; ad;</span><br><span class="line"><span class="keyword">typedef</span> Array&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; ai;</span><br></pre></td></tr></table></figure>

<p>有多少个就得写多少次，然而非模板参数<code>10</code>是固定的。</p>
<p>C++ 11新增了使用模板提供一系列别名的功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> arrtype = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T, <span class="number">12</span>&gt;;  <span class="comment">// template to create multiple aliases</span></span><br></pre></td></tr></table></figure>

<p><code>arrtype</code>为模板别名，可使用它来指定类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrtype&lt;<span class="keyword">int</span>&gt; ai;</span><br></pre></td></tr></table></figure>

<p>C++ 11允许将语法<code>using =</code>用于非模板，此时与使用<code>typedef</code>等价：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">char</span> * pc1;</span><br><span class="line"><span class="keyword">using</span> pc2 = <span class="keyword">const</span> <span class="keyword">char</span> *;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">int</span> *(*pa1)[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">using</span> pa2 = <span class="keyword">const</span> <span class="keyword">int</span> *(*)[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3><span id="32-类和动态内存分配">32. 类和动态内存分配</span></h3><p>如果派生类不使用new，则不需要定义析构函数、复制构造函数和赋值构造函数。对于派生类中的新成员，默认复制或赋值构造函数都可以处理，对于继承得到的基类对象，C++成员复制将根据数据类型采用相应的复制方式，复制类成员或继承的类组件时，使用该类的复制构造函数完成，所以派生类的默认构造函数将使用基类的复制构造函数复制基类对象，这对于赋值也是同理，因此可以不用自行定义。</p>
<p>如果派生类使用了new，则必须为派生类定义显式析构函数、复制构造函数和重载赋值运算符。派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行的工作进行清理（简单地说，就是各管各的，构造函数增量式更新，析构函数对应撤销更新）。对于复制构造函数，派生类不能访问基类数据，因此必须调用基类复制构造函数来处理共享的基类数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须显式定义复制构造函数</span></span><br><span class="line">Derived::Derived(<span class="keyword">const</span> Derived &amp; rd) : Base(rd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// initialize new members</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，成员初始化列表将一个<code>Derived</code>引用传递给<code>Base</code>构造函数，这是因为Base有一个复制构造函数，而基类引用可以指向派生类，所以没有问题。</p>
<p>对于赋值运算符函数，需要显式调用基类的赋值运算符函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须显式定义赋值运算符函数</span></span><br><span class="line">Derived &amp; Derived::<span class="keyword">operator</span>=(<span class="keyword">const</span> Derived &amp; rd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rd)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rd);  <span class="comment">// copy base portion</span></span><br><span class="line">    <span class="comment">// copy new members</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong>：当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的基类方法来处理基类元素。这种要求是通过三种不同的方式来满足的。对于析构函数，这是自动完成的；对于构造函数，这时通过在初始化成员列表中调用基类的复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函数。对于赋值运算符，这是通过使用作用域解析运算符显式地调用基类的赋值运算符来完成的。</p>
<p>函数传参、返回值与对象拷贝：</p>
<ol>
<li>无论是哪种编译器，当按值传递和返回对象时，都将调用复制构造函数。</li>
<li>由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。</li>
<li>如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。</li>
<li>对象初始化总会调用复制构造函数，而使用=运算符也可能调用赋值运算符函数。</li>
</ol>
<h3><span id="33-友元-异常和其他">33. 友元、异常和其他</span></h3><p><strong>友元类</strong>：可以将类作为友元，友元类的的所有方法都可以访问原始类的私有成员和保护成员。</p>
<p>友元类声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span>;</span></span><br></pre></td></tr></table></figure>
<p>友元声明可以位于公有、私有或保护部分，其所在的位置无关紧要。</p>
<p><strong>友元成员函数</strong>：选择特定的类成员函数成为另一个类的友元。</p>
<p>友元成员函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span>  <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">void</span> FriendClass:memberFunc();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了让编译器识别<code>FriendClass</code>是一个类，需要使用前向声明，排列顺序如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span>,..&#125;;</span><br></pre></td></tr></table></figure>
<p>被声明为友元的类和方法必须先声明。</p>
<p>如果作为友元的类中的内联方法调用了<code>MyClass</code>中的方法，此时编译器必须看到<code>MyClass</code>类的声明，这样才能知道<code>MyClass</code>类有哪些方法。可以只在<code>FriendClass</code>类中只作声明，然后把实际的的定义放在<code>MyClass</code>类之后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span>,..&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> FriendClass <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;  <span class="comment">// can be inline method</span></span><br></pre></td></tr></table></figure>
<p>让整个类成为友元不需要前向声明，因为友元语句本身已经指出<code>FriendClass</code>是一个类了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span>;</span></span><br></pre></td></tr></table></figure>


<p><strong>互为友元</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(FriendClass &amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MyClass obj)</span> </span>&#123;obj.show();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> MyClass:display(FriendClass &amp; obj) &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MUTUAL_FRIEND_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MUTUAL_FRIEND_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(FriendClass &amp;obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MyClass &amp;obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call MyClass::show&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        obj.show(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MyClass::show</span><span class="params">(FriendClass &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt++ &lt;= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call FriendClass::show&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        obj.show(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bye~~&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<p><strong>共同友元</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMMON_FRIEND_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMON_FRIEND_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GPU</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(CPU &amp;, <span class="keyword">const</span> GPU &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(GPU &amp;, <span class="keyword">const</span> CPU &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GPU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(CPU &amp;, <span class="keyword">const</span> GPU &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(GPU &amp;, <span class="keyword">const</span> CPU &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(CPU &amp;cpu, <span class="keyword">const</span> GPU &amp;gpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cpu.data = gpu.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(GPU &amp;gpu, <span class="keyword">const</span> CPU &amp;cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gpu.data = cpu.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<p><strong>嵌套类</strong>：可以将类声明放在另一个类中，仅当声明位于公有部分时，才能在包含类的外面使用嵌套类，且必须使用作用域解析运算符。嵌套类不是类对象包含，它不创建类成员，而是定义了一种类型，该类型仅在包含嵌套类声明的类中有效。</p>
<p>对类进行嵌套通常是为了帮助实现另一个类，并避免名称冲突。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        InnerClass() &#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InnerClass method definition</span></span><br><span class="line"><span class="keyword">void</span> OuterClass::InnerClass::show() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>==嵌套类的作用域==：如果嵌套类<code>A</code>是在另一个类<code>B</code>的私有部分声明的，那么从类<code>B</code>派生出来的类<code>C</code>中，<code>A</code>也是不可见的，因为派生类不能直接访问基类的私有部分。如果嵌套类<code>A</code>是在另一个类<code>B</code>的保护部分声明的，那么从类<code>B</code>派生出来的类<code>C</code>中，<code>A</code>也是可见的。</p>
<p>==模板中的嵌套类==：嵌套类可以使用模板参数类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueTP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Q_SIZE = <span class="number">10</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Node is a nested class definition</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Item item;  <span class="comment">// use Item type</span></span><br><span class="line">        Node *next;</span><br><span class="line">        Node(<span class="keyword">const</span> Item &amp;i) : item(i), nxet(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Node</code>类不是模板类，但是使用了模板参数<code>Item</code>。</p>
<p>假如同时有<code>QueueTP&lt;double&gt; dq</code>和<code>QueueTP&lt;char&gt; cq</code>两个声明，则这两个<code>Node</code>类将在两个独立的<code>QueueTP</code>类中定义，因此不会发生名称冲突，即一个节点的类型为<code>QueueTP&lt;double&gt;::Node</code>，另一个节点的类型为<code>QueueTP&lt;char&gt;::Node</code>。</p>
<p><strong>异常处理</strong>：</p>
<ol>
<li><p>引发异常：</p>
<p>语法：<code>throw type</code>，<code>type</code>可以是任意C++类型，通常是类类型，用于指出异常的特征。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="string">&quot;ValueError&quot;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>使用异常处理程序捕获异常：</p>
<p>处理程序以关键字<code>catch</code>开头，随后是位于括号中的类型说明，它指出了异常处理程序要响应的异常类型，然后是用一个花括号括起的代码块，指出要采取的措施。<code>catch</code>关键字和异常类型用作标签，指出当异常被引发时，程序应调到这个位置执行。异常处理程序也被称为<code>catch</code>块。程序将寻找与引发的异常类型匹配的异常处理程序（位于<code>try</code>块后面）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// similar to function definition</span></span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span> * s)  <span class="comment">// start of exception handler</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>使用<code>try</code>块：</p>
<p><code>try</code>块标识其中特定的异常可能被激活的代码块，它后面跟一个或多个<code>catch</code>块。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  <span class="comment">// start of try block</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数引发了异常，而没有<code>try</code>块或者匹配的处理程序时，程序最终将调用<code>abort()</code>函数。</p>
</li>
</ol>
<p>异常处理示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassName &amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// how C++ manages obj?</span></span><br><span class="line">    <span class="keyword">throw</span>;  <span class="comment">// rethrows the exception</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>==异常规范==：告诉用户可能需要使用<code>try</code>块，或让编译器添加执行运行阶段检查的代码，检查是否违反了异常规范。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// func doesn&#x27;t throw an exception</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span> <span class="params">()</span> </span>&#123;&#125;  <span class="comment">// same as above</span></span><br></pre></td></tr></table></figure>


<p>==栈解退==：函数由于出现异常而终止，程序将释放栈中的内存，直到找到<code>try</code>块中的返回地址。和函数返回一样，对于栈中的自动类对象，类的析构函数将被调用。</p>
<p>疑问点：如果<code>catch</code>块使用了对象引用，程序不会再回到调用函数里面，而异常类型对象是在调用函数里面创建的，这时候该对象在内存中是如何管理的？</p>
<p>答：引发异常时编译器总是创建一个临时拷贝，即使异常规范和<code>catch</code>块中指定的是引用。</p>
<p>==提示==：如果有一个异常类继承层次结构，应该这样排列<code>catch</code>块：将捕获位于层次结构最下面的异常类的<code>catch</code>语句放在最前面，将捕获基类异常的<code>catch</code>语句放在最后面。    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroDivisionError</span> :</span> <span class="keyword">public</span> BaseException &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileNotFoundError</span> :</span> <span class="keyword">public</span> BaseException &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundError &amp; err) &#123;&#125;</span><br><span class="line"><span class="keyword">catch</span> (ZeroDivisionError &amp; err) &#123;&#125;</span><br><span class="line"><span class="keyword">catch</span> (BaseException &amp; err) &#123;&#125;</span><br></pre></td></tr></table></figure>


<p>==提示==：即使不知道异常的类型，也可以通过使用省略号来任何捕获异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (...) &#123;&#125;  <span class="comment">// catches any type exception</span></span><br></pre></td></tr></table></figure>
<p>如果仅知道部分会引发的异常，可以将省略号放至<code>catch</code>块的最后面，有点类似<code>switch</code>语句汇总的<code>default</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;FileNotFoundError &amp; err&#125; &#123;&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;ZeroDivisionError &amp; err&#125; &#123;&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;...&#125; &#123;&#125;  <span class="comment">// catch whatever is left</span></span><br></pre></td></tr></table></figure>


<p>==空指针和new==：很多代码都是在<code>new</code>失败时返回空指针时编写的，为了处理<code>new</code>使用异常的变化，有些编译器提供了一个标记（开关），让用户选择所需的行为，当前，C++标准提供了一种在失败时返回空指针的<code>new</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>


<p>==注意==：</p>
<ol>
<li><p>如果异常是在带异常规范的函数中引发的，则必须与规范列表中的某种异常匹配（在继承层次结构中，类类型与这个类及其派生类的对象匹配），否则称为意外异常。在默认情况下，这会导致程序异常终止。</p>
</li>
<li><p>如果异常没有被捕获（在没有<code>try</code>块或没有匹配的<code>catch</code>块时），该异常被称为未捕获异常。在默认情况下，这会导致程序异常终止。未捕获异常不会导致程序立刻异常终止，程序将首先调用函数<code>terminate()</code>。在默认的情况下，<code>terminate()</code>函数调用<code>abort()</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQuit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Terminating due to uncaught exception\n&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_terminate(myQuit);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>异常规范不适用于模板，因为模板函数引发的异常可能随特定的具体化而异。</p>
</li>
</ol>
<p><strong>RTII</strong>：<code>RTII</code>是运行阶段类型识别（Runtime Type Identification）的简称。</p>
<p>==RTII的作用==：从基类指针中获取对象的类型。在公有派生中，如果使用了虚函数，则可以使用基类指针调用派生类对象的虚方法，如果派生类对象有自定义的方法，则无法通过基类指针进行调用。</p>
<p>C++有3个支持<code>RTII</code>的元素：</p>
<ol>
<li>如果可能的话，<code>dynamic_cast</code>运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则，该运算符返回0——空指针。</li>
<li><code>typeid</code>运算符返回一个指出对象的类型的值。</li>
<li><code>type_info</code>结构存储了有关特定类型的信息。</li>
</ol>
<p>只能将<code>RTII</code>用于包含虚函数的类层次结构，原因在于只有对这种类层次结构，才应该将派生对象的地址赋给基类指针。</p>
<p>==dynamic_cast语法==：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span> &lt;type-name&gt; (expression)</span><br></pre></td></tr></table></figure>
<p>如果不能安全执行转换，则结果为空指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">赋值表达式的值是它左边的值，因此`if`条件的值为pt，如果类型转换成功，则pt的值为非零，如果类型转换失败，则pt的值将为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (pt = <span class="keyword">dynamic_cast</span>&lt;Foo *&gt;(p))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以将<code>dynamic_cast</code>用于引用，但由于没有与空指针对应的引用值用于表示转换失败，<code>dynamic_cast</code>使用<code>bad_cast</code>异常来指出转换失败，该异常类型是从<code>exception</code>类派生出来的，在<code>typeinfo</code>头文件中定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Foo &amp; foo = <span class="keyword">dynamic_cast</span>&lt;Foo &amp;&gt;(bar);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="built_in">std</span>::bad_cast &amp;) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>==typeid运算符和type_info类==：</p>
<p><code>typeid</code>运算符功能类似于Python语言中的<code>type</code>，可以接受两种参数：</p>
<ol>
<li>类名</li>
<li>结果为对象的表达式</li>
</ol>
<p><code>typeid</code>运算符返回一个对<code>type_info</code>对象的引用，其中<code>type_info</code>是在头文件<code>typeinfo</code>中定义的一个类，它重载了<code>==</code>和<code>!=</code>运算符，以便可以使用这些运算符来对类型进行比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeid</span>(Foo) == <span class="keyword">typeid</span>(*foo)</span><br></pre></td></tr></table></figure>
<p>如果<code>*foo</code>指向<code>Foo</code>对象，则上述表达式的值为<code>true</code>。如果<code>foo</code>是一个空指针，程序将引发<code>bad_typeid</code>异常，该异常同样是在<code>typeinfo</code>头文件中声明的。</p>
<p><code>type_info</code>类的实现随厂商而异，但包含一个<code>name()</code>成员，该函数返回一个随实现而异的字符串：通常（但不一定）是类名。</p>
<p><strong>类型转换运算符</strong>：</p>
<p>==const_cast==：<code>const_cast</code>运算符用于执行只有一种用途的类型转换，即改变值为<code>const</code>或<code>volatile</code>，语法规则为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const_cast</span>&lt;type-name&gt;(expression)</span><br></pre></td></tr></table></figure>
<p>其中，<code>type-name</code>和<code>expression</code>的类型必须相同。</p>
<p>提供该运算符的原因是，有时候可能需要这样一个值，它在大多数时候是常量，而有时又是可以修改的。在这种情况下，可以将这个值声明为<code>const</code>，并在需要修改它的时候，使用<code>const_cast</code>。</p>
<p><code>const_cast</code>可以修改指向一个值的指针，但修改<code>const</code>值的结果是不确定的，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> foo = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bar = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = &amp;foo;</span><br><span class="line"><span class="keyword">int</span> * pc = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(pt);</span><br><span class="line">*pc = <span class="number">20</span>;  <span class="comment">// Ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = &amp;bar;</span><br><span class="line"><span class="keyword">int</span> * pc = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(pt);</span><br><span class="line">*pc = <span class="number">20</span>;  <span class="comment">// has no effect</span></span><br></pre></td></tr></table></figure>
<p>==static_cast==：仅当<code>type-name</code>可被隐式转换为<code>expression</code>所属的类型或<code>expression</code>可被隐式转换为<code>type_name</code>所属的类型时，转换才是合法的，否则将出错。可用于类继承层次中的向上或向下转换，但是不能用于不相关类型的互相转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;type-name&gt;(expression)</span><br></pre></td></tr></table></figure>


<h3><span id="34-string类和标准模板库">34. string类和标准模板库</span></h3><p><strong>string类</strong>：</p>
<ol>
<li><p><code>string</code>类实际上是模板具体化<code>basic_string&lt;char&gt;</code>的一个typedef，同时省略了内存管理相关的参数。</p>
</li>
<li><p><code>string</code>类的一个带模板参数的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="built_in">string</span>(Iter begin, Iter end)</span><br></pre></td></tr></table></figure>
<p>将<code>string</code>对象初始化为区间<code>[begin, end)</code>内的字符，其中<code>begin</code>和<code>end</code>的行为就像指针，用于指定位置，它们指向内存中的两个位置。</p>
</li>
</ol>
<p><strong>智能指针模板类</strong>：</p>
<p>三个智能指针模板（<code>auto_ptr</code>， <code>unique_ptr</code>和<code>shared_ptr</code>）都定义了类似指针的对象，可以将<code>new</code>获得的地址赋给这种对象，当智能指针过期时，其析构函数将使用<code>delete</code>来释放内存。</p>
<p>要创建智能指针对象，必须包含头文件<code>memory</code>。创建智能指针对象的语法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">pd</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">pd</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">pd</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ClassName&gt; <span class="title">pt</span><span class="params">(<span class="keyword">new</span> ClassName)</span></span>;</span><br><span class="line">pt-&gt;show();  <span class="comment">// 对象的方法是如何获取到的呢？</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组类型，智能指针将使用delete []</span></span><br><span class="line">std::unique_ptr&lt;double []&gt; pda (new double [5]);</span><br><span class="line">std::shared_ptr&lt;double []&gt; pda (new double [5]);</span><br></pre></td></tr></table></figure>
<p>假如<code>pt</code>是智能指针对象，则可以对它执行解除引用操作（<code>*pt</code>）、用它来访问结构成员（<code>pt-&gt;show</code>）、将它赋给指向同类型的常规指针。</p>
<p>==注意==：避免将智能指针用于非堆内存。</p>
<p>==赋值运算==：</p>
<ol>
<li><p><code>auto_ptr</code>和<code>unique_ptr</code>使用所有权管理对象，对于特定的对象，只能有一个智能指针可拥有它，拥有所有权的智能指针的析构函数会删除该对象。赋值操作转让所有权，对于<code>auto_ptr</code>，右值将变成空指针，而对于<code>unique_ptr</code>，如果右值不是临时对象，会产生编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">pt</span><span class="params">(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;Hello World&quot;</span>))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">    pu2 = pu1; <span class="comment">// not allowed</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">    pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;World&quot;</span>)); <span class="comment">// allowed</span></span><br><span class="line"></span><br><span class="line">    pu2 = func(); <span class="comment">// allowd</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><code>shared_ptr</code>使用对象引用计数法。<code>shared_ptr</code>更接近于常规指针。模板<code>shared_ptr</code>包含一个显式构造函数，可用于将右值<code>unique_ptr</code>转换为<code>shared_ptr</code>，<code>shared_ptr</code>将接管原来归<code>unique_ptr</code>所有的对象。当<code>unique_ptr</code>是临时右值时，可以将一个<code>unique_ptr</code>赋给<code>shared_ptr</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pt = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>));</span><br></pre></td></tr></table></figure>

</li>
<li><p>智能指针选择：一般来说，如果程序需要多个指向同一个对象的指针，可以使用<code>shared_ptr</code>，否则使用<code>unique_ptr</code>。</p>
</li>
</ol>
<p><strong>标准模板库</strong>：STL提供了一组表示容器、迭代器、函数对象和算法的模板。</p>
<p>容器是一个与数组类似的单元，可以存储若干个值。STL容器是同质的，即存储的值的类型相同；迭代器能够用来遍历容器的对象，是广义指针；函数对象是类似于函数的对象，可以是类对象或函数指针（包括函数名）。</p>
<ol>
<li><p>分配器：各种STL容器模板都可接收一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存。如果省略该模板参数值，则容器模板将默认使用<code>allocator&lt;T&gt;</code>类，这个类使用<code>new</code>和<code>delete</code>。</p>
</li>
<li><p>迭代器：迭代器是一个广义指针。事实上，它可以是指针，也可以是一个可对其执行类似指针的操作（如解除引用和递增）的对象。每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为<code>iterator</code>的<code>typedef</code>，其作用域为整个类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::iterator iter;  <span class="comment">// iter: an iterator</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; scores;</span><br><span class="line">iter = scores.begin();  <span class="comment">// have iter point to the first elememt</span></span><br><span class="line">*iter = <span class="number">100</span>;</span><br><span class="line">++iter;  <span class="comment">// make iter point to the next element</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> iter = scores.begin();  <span class="comment">// C++ 11 automatic type deduction</span></span><br></pre></td></tr></table></figure>
<p><code>end()</code>成员函数标识超过结尾的位置，即指向容器最后一个元素后面的那个元素。</p>
<p>==注意==：区间<code>[it1, it2)</code>由迭代器<code>it1</code>和<code>it2</code>指定，其范围为<code>it1</code>到<code>it2</code>（不包含<code>it2</code>）。</p>
<p>STL定义了5种迭代器，并根据所需的迭代器类型对算法进行了描述。这5种迭代器分别是输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器。</p>
<p>==输入迭代器==：</p>
<p>输入迭代器可被程序用来读取容器中的信息，对输入迭代器解除引用将使程序能够读取容器中的值，但不一定能让程序修改值。因此，需要输入迭代器的算法将不会修改容器中的值。基于输入迭代器的任何算法都应当是单通行的，不依赖于前一次遍历时的迭代器值，也不依赖本次遍历中前面的迭代器值。输入迭代器是单向迭代器，可以递增，但不能倒退。</p>
<p>==输出迭代器==：</p>
<p>程序的输出就是容器的输入。</p>
<p>对于单通行、只读算法，可以使用输入迭代器，对于单通行、只写算法，可以使用输出迭代器。</p>
<p>==正向迭代器==：</p>
<p>可读写，适用于多次通行算法，每次遍历的顺序都相同，迭代器递增后，仍然可以对前面的迭代器值解除引用，并得到相同的值。</p>
<p>==双向迭代器==：</p>
<p>与正向迭代器类似，但支持递增、递减两种操作。</p>
<p>==随机访问迭代器==：</p>
<p>支持随机访问。</p>
<p>STL迭代器描述了一系列要求，称为概念，概念的具体实现被称为模型。模型可以使用任何符合要求的实现。因此STL算法可以使用指针来对基于指针的非STL容器进行操作。</p>
<p>常规指针可以作为迭代器，因此STL算法可以使用指针来对基于指针的非STL容器进行操作。例如，可以将STL算法用于数组。</p>
</li>
<li><p>算法组：算法通常作为非成员函数，但对于特定的类，可能存在特定算法，其效率比通用算法高。常用的STL函数有：<code>for_each()</code>和<code>sort</code>等。使用类方法可以自动调用类的内存管理工具，在需要的时候调整容器的长度，而通用算法不能调用容器类方法，可能需要搭配其他的类方法进行使用，如<code>remove</code>函数和<code>list&lt;int&gt;::erase</code>方法搭配使用等价于使用<code>list&lt;int&gt;::remove</code>方法。</p>
<p><code>for_each()</code>函数类似于Python中的<code>map</code>函数，其用法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(vec.begin(), vec.end(), func);</span><br><span class="line"><span class="comment">// func函数接受引用参数时，可以修改容器的内容</span></span><br></pre></td></tr></table></figure>
<p>也可以用基于范围的<code>for</code>循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) func(x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : vec) func(x);  <span class="comment">// 可修改容器的内容</span></span><br></pre></td></tr></table></figure>


<p><code>sort()</code>函数要求容器支持随机访问，该函数有两个版本：</p>
<ul>
<li><p>接受两个定义区间的迭代器参数，并使用为存储在容器中的类型定义的<code>&lt;</code>运算符，对区间中的元素进行操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(vec.begin(), vec.end());</span><br></pre></td></tr></table></figure>
<p>如果是自定义的对象，必须定义<code>operator&lt;()</code>函数。</p>
</li>
<li><p>接收三个参数，前两个参数也是指定区间的迭代器，最后一个参数是指想要使用的函数的指针（函数对象）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(Ele &amp; e1, Ele &amp; e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e1 &lt; e2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(vec.begin(), vec.end(), func);</span><br></pre></td></tr></table></figure>
<p>在全排序中，如果<code>a &lt; b</code>和<code>b &lt; a</code>都不成立，则<code>a</code>和<code>b</code>必定相同。在完整弱排序中，它们可能相同，也可能只是在某方面相同。</p>
</li>
</ul>
<p><code>copy()</code>可以将数据从一个容器复制到另一个容器中。需要保证目标容器有足够的容量进行复制。可以使用<code>ostream_iterator</code>模板将信息复制到显示器上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line">ostream_iterator&lt;int, char&gt; out_iter(cout, &quot; &quot;);</span><br><span class="line">copy(arr.begin(), arr.end(), out_iter);</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>istream_iterator</code>模板接收输入信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(istream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;(<span class="built_in">cin</span>), istream_iterator&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;(), vect.begin());  <span class="comment">// 可以使用匿名对象</span></span><br></pre></td></tr></table></figure>
<p>省略构造函数参数表示输入失败，因此上述代码从输入流中读取，直到文件结尾、类型不匹配或出现其他输入故障为止。</p>
<p>使用插入迭代器<code>back_insert_iterator</code>，<code>front_insert_iterator</code>和<code>insert_iterator</code>，可以自动扩容目标容器。即可以用<code>insert_iterator</code>将复制数据的算法转换为插入数据的算法。</p>
<p>这些迭代器将容器类型作为模板参数，将实际的容器标识符作为构造函数参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">back_insert_iterator&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; back_iter(dice);</span><br></pre></td></tr></table></figure>
<p>STL将算法库分为4组：</p>
<ul>
<li>非修改式序列操作；</li>
<li>修改式序列操作；</li>
<li>排序和相关操作；</li>
<li>通用数字运算。</li>
</ul>
<p>前3组在头文件<code>algorithm</code>中描述，第4组在<code>numeric</code>中描述。</p>
<p>有些算法有两个版本：<code>in-place</code>版本和<code>copy</code>版本，STL的规定是，复制版本的名称将以<code>_copy</code>结尾。</p>
</li>
<li><p>泛型编程</p>
<p>面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。泛型编程旨在使用同一个函数来处理数组、链表或任何其他容器类型，即函数不仅独立于容器中存储的数据类型，而且独立于容器本身的数据结构。模板提供了存储在容器中的数据类型的通用表示，因此还需要遍历容器中的值的通用表示，迭代器正是这样的通用表示。</p>
</li>
<li><p>容器</p>
<p>==容器概念==：</p>
<p>存储在容器中的数据为容器所有，这意味着当容器过期时，存储在容器中的数据也将过期。</p>
<p>==关联容器==：</p>
<p>键值对容器，使用键来查找值。STL提供了4中关联容器：<code>set</code>、<code>multiset</code>、<code>map</code>和<code>multimap</code>。</p>
<p>最简单的关联容器是<code>set</code>，其值类型与键相同，对于<code>set</code>来说，值就是键。<code>multiset</code>类似于<code>set</code>，只是可能有多个值的键相同。</p>
</li>
<li><p>函数对象</p>
<p>函数对象，也叫函数符。函数符是可以以函数方式与<code>()</code>结合使用的任意对象，包括函数名，指向函数的指针和重载了<code>()</code>运算符的类对象（<code>operator()()</code>）。不接受参数的函数对象称为生成器。</p>
<p>STL通过使用模板解决了函数符传参问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator first, InputIterator last, Function f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意，函数指针不能解决该问题。</p>
<p>==自适应函数符==：携带了标识参数类型和返回类型的<code>typedef</code>成员，如<code>result_type</code>、<code>first_argument_type</code>和<code>second_argument_type</code>。接受一个自适应函数符参数的函数可以使用<code>result_type</code>成员来声明一个与函数的返回类型匹配的变量。</p>
<p>==函数适配器==：用于改变函数的输入参数个数。STL使用<code>binder1st</code>和<code>binder2nd</code>类自动完成这一过程，将自适应二元函数转换为自适应一元函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line">binder1st(func, val) uni_func;</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>bind1st()</code>和<code>bind2nd()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind1st(multiplies&lt;<span class="keyword">double</span>&gt;(), <span class="number">2.5</span>);  <span class="comment">// 声明了一个匿名multiplies&lt;double&gt;函数对象</span></span><br></pre></td></tr></table></figure>
<p>类似于Python中的<code>partial</code>。</p>
<p>C++11已经抛弃了<code>binder1st</code>和<code>binder2nd</code>，可以用<code>bind</code>进行替代。</p>
</li>
<li><p>其他库</p>
<p>==vector、valarray和array==：<code>valarray</code>类是面向数值计算的，有点类似于<code>numpy</code>。<code>valarray</code>没有提供<code>begin()</code>和<code>end()</code>迭代器，也不能使用<code>&amp;ar[0]</code>的方式给算法提供参数，C++提供了接受<code>valarray</code>对象作为参数的模板函数<code>begin()</code>和<code>end()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(begin(ar), end(ar));</span><br></pre></td></tr></table></figure></li>
<li><p>模板<code>initializer_list</code>：</p>
<p>在定义接受<code>initializer_list</code>参数的构造函数之后，可以使用初始化列表语法将STL容器初始化为一系列值（此时初始化列表语法就只能用于该构造函数）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; payments &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>要在代码中使用<code>initializer_list</code>对象，必须包含头文件<code>initializer_list</code>，这个模板类包含成员函数<code>begin()</code>和<code>end()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; il)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = il.begin(); p != il.end(); p++)</span><br><span class="line">        tot += *p;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了用于构造函数为，还可以将<code>initialize_list</code>用于常规函数的参数。</p>
</li>
</ol>
<h3><span id="35-io">35 IO</span></h3><ol>
<li><p><code>setf(fmtflags, fmtflags)</code>的函数重载中，第一个参数用于设置位，第二个参数用于清除位，可以通过查表获得可用参数值。</p>
</li>
<li><p><code>unsetf(fmtflags)</code>可以撤销修改。</p>
</li>
<li><p><code>iomanip</code>头文件提供了设置格式的便捷工具。</p>
</li>
<li><p>命令行处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>二进制读写文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fout.write((<span class="keyword">char</span> *) &amp;structure, <span class="keyword">sizeof</span> structure);</span><br><span class="line">fin.read((<span class="keyword">char</span> *)&amp;structure, <span class="keyword">sizeof</span> structure);</span><br></pre></td></tr></table></figure>
<p>适用于不使用虚函数的类，此时类的数据成员被保存，而方法不会被保存。如果类有虚方法，则也将复制隐藏指针（指向虚函数的指针表）。</p>
</li>
<li><p><code>seekg()</code>用于输入指针，<code>seekp()</code>用于输出指针。<code>fstream</code>对象同步管理读写指针，而如果分开使用<code>ifstream</code>和<code>ofstream</code>对象管理同一个文件，则读写指针独立。</p>
</li>
<li><p>临时文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> tmp[L_tmpname] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">tmpnam(tmp);</span><br></pre></td></tr></table></figure>
<p><code>tmpname</code>函数创建了一个临时文件名，<code>L_tmpnam</code>和<code>TMP_MAX</code>限制了文件名包含的字符数以及在确保当前目录中不生成重复文件名的情况下函数可被调用的最多次数。</p>
</li>
<li><p><code>sstream</code>提供程序与<code>string</code>对象之间的I/O。读取<code>string</code>对象中的格式化信息或将格式化信息写入<code>string</code>对象中被称为内核格式化。在需要的情况下，<code>ostringstream</code>对象将使用动态内存分配来增大缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">ostringstream</span> outstr;</span><br><span class="line">    outstr &lt;&lt; <span class="string">&quot;some message goes into the string&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> result = outstr.str();  <span class="comment">// freeze the object</span></span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">instr</span> <span class="params">(result)</span></span>;</span><br><span class="line">    instr &gt;&gt; obj;</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3><span id="36-c11">36 C++11</span></h3><ol>
<li><p>右值引用：将右值关联到右值引用将导致该右值被存储到特定的位置，且可以获取该位置的地址。引入右值引用的主要目的之一是实现移动语义。此时右值的生命周期与右值引用一样长。</p>
</li>
<li><p>移动语义：临时对象（如函数返回值）被删除时，使用所有权转让的方式而不是深度拷贝的方式给新变量赋值。复制构造函数可执行深度拷贝，而移动构造函数只调整记录。移动构造函数的逻辑还是需要自己进行实现的，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String::String(String &amp;&amp; s) : size(s.size)  <span class="comment">// 由于修改了s对象，不能添加const关键字</span></span><br><span class="line">&#123;</span><br><span class="line">    pt = s.pt;</span><br><span class="line">    s.size = <span class="number">0</span>;</span><br><span class="line">    s.pt = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String String::<span class="keyword">operator</span>+(<span class="keyword">const</span> String &amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    String temp;</span><br><span class="line">    <span class="comment">// construct temp from *this and s</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">s</span><span class="params">(s1 + s2)</span></span>;  <span class="comment">// calls move constructor</span></span><br><span class="line"><span class="comment">// Note: 程序可能不调用移动构造函数，编译器可能会进行优化，直接完成移动构造函数所做的工作</span></span><br></pre></td></tr></table></figure>
<p>Q：多层级动态内存分配的数据结构如何保证正确地修改记录呢？A：将调用各成员的移动构造函数</p>
</li>
<li><p>移动构造函数解析：</p>
<p>第一步：根据值的类型（左值或者右值），调用复制构造函数或者移动构造函数。</p>
<p>第二步：编写移动构造函数。</p>
</li>
<li><p>移动赋值运算符函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String &amp; String::<span class="keyword">operator</span>=(String &amp;&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    pt = s.pt;</span><br><span class="line">    s.size = <span class="number">0</span>;</span><br><span class="line">    s.pt = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>强制使用移动（赋值）构造函数：左值转右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择一</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;String &amp;&amp;&gt; str;</span><br><span class="line"><span class="comment">// 选择二</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line">str2 = <span class="built_in">std</span>::move(str1)</span><br></pre></td></tr></table></figure></li>
<li><p>默认的方法和禁用的方法：</p>
<p>如果提供了某些构造函数（如移动构造函数），编译器不会自动创建默认的构造函数、复制构造函数和赋值构造函数。在这些情况下，可以使用关键字<code>default</code>显式地声明这些方法的默认版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Someclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Someclass() = <span class="keyword">default</span>;  <span class="comment">// use compiler-generated default constructor</span></span><br><span class="line">    Someclass(Someclass &amp;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关键字<code>delete</code>可用于禁止编译器使用特定方法，例如，要禁止复制对象，可禁用复制构造函数和赋值运算符函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Someclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Someclass(<span class="keyword">const</span> Someclass &amp;) = <span class="keyword">delete</span>;  </span><br><span class="line">    Someclass &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Someclass &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关键字<code>default</code>只能用于6个特殊成员函数，但<code>delete</code>可用于任何成员函数。<code>delete</code>的一种可能用法是禁止特定的转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Someclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   	<span class="function"><span class="keyword">void</span> <span class="title">redo</span><span class="params">(<span class="keyword">int</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redo</span><span class="params">(<span class="keyword">double</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>obj.redo(5)</code>与<code>redo(int)</code>匹配，编译器检测到这一点以及<code>redo(int)</code>被禁用后，将这种调用视为编译错误。</p>
</li>
<li><p>继承基类构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b,c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base();</span><br><span class="line">    Base(<span class="keyword">int</span>);</span><br><span class="line">    Base(<span class="keyword">double</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base; <span class="comment">// C++ 11将using用于构造函数，让派生类继承基类的所有构造函数（默认构造函数、复制构造函数和移动构造函数除外），但不会使用派生类构造函数的特征标匹配的构造函数</span></span><br><span class="line">    Derived();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果没有匹配的派生类构造函数，将调用基类与参数匹配的构造函数，但是派生类的数据成员不会被初始化。</p>
</li>
<li><p><code>override</code>和<code>final</code>：</p>
<p>在继承层次结构中，如果派生类重新定义方法（不管特征标是否相同），则新方法将隐藏旧所有基类方法，导致派生类对象不可调用基类方法。</p>
<p>虚说明符<code>override</code>指出要覆盖一个虚函数，放置于参数列表后面，如果声明与基类方法不匹配，编译器将视为错误（常用于检测typo）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">char</span> * ch)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>说明符<code>final</code>用于禁止派生类覆盖特定的虚方法，放置于参数列表后面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">char</span> * ch)</span> <span class="keyword">const</span> <span class="keyword">final</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Lambda</code>函数：C++不允许嵌套定义函数，函数可以在函数中定义<code>Lambda</code>表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](type var) &#123;<span class="keyword">return</span> expression;&#125;</span><br></pre></td></tr></table></figure>
<p>仅当<code>lambda</code>表达式完全由一条返回语句组成时，自动类型推断才管用，否则需要使用新增的返回类型后置语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](type var)-&gt;type(statements; <span class="keyword">return</span> expression;)</span><br></pre></td></tr></table></figure>
<p>但是可以使用三目运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x) &#123;<span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">3.14</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>在多次调用<code>Lambda</code>函数的时候，可以给<code>lambda</code>指定一个名称：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](type var) &#123;<span class="keyword">return</span> expression;&#125;</span><br></pre></td></tr></table></figure>
<p><code>lambda</code>函数可访问作用域内的任何动态变量，要捕获要使用的变量，可将其名称放在中括号内，如果只指定了变量名，将按值访问变量，如果在名称前加上<code>&amp;</code>，将按引用访问变量。<code>[&amp;]</code>能够按照引用访问所有动态变量，而<code>[=]</code>能够按值访问所有动态变量。还可以混合使用这两种方式，如<code>[val1, &amp;val2]</code>能够按值访问<code>val1</code>以及按引用访问<code>val2</code>。<code>[&amp;, val]</code>可以按值访问<code>val</code>以及按引用访问其他所有静态变量。<code>[=, &amp;val]</code>可以按引用访问<code>val</code>以及按值访问其他所有动态变量。</p>
</li>
<li><p>包装器：</p>
<p>由于函数对象的多样性（函数指针，函数对象，Lambda表达式），将函数对象传递给模板函数时，不同的函数对象会实例化不同的模板函数，导致模板效率低下。使用包装器可以减少实例化次数。</p>
<p>模板<code>function</code>是正在头文件<code>functional</code>中声明的，它从调用特征标的角度定义了一个对象，可用于包装调用特征标相同的函数指针、函数对象或<code>lambda</code>表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">char</span>, <span class="keyword">int</span>)&gt; fdci = func;  <span class="comment">// 接收一个`char`参数和一个`int`参数并返回`double`值的`function`对象</span></span><br></pre></td></tr></table></figure>
<p>调用特征标：是由返回类型以及用括号括起并用逗号分隔的参数类型列表定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">function</span>;</span>  <span class="comment">// 不能没有主模板，只有偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Arg&gt;  <span class="comment">// 偏特化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>&lt;</span>R(Arg)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(arg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用包装器，本质上还是会用到多个实例化，但是如果包装器类比接收函数对象的模板函数轻量，还是更加有优势的。</p>
<p>也可以在模板函数的定义中，用包装器替换模板参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T a, <span class="built_in">std</span>::function&lt;T(T)&gt; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func&lt;<span class="keyword">double</span>&gt; (<span class="number">3.0</span>, f);</span><br></pre></td></tr></table></figure>
<p>由于<code>f</code>并不是<code>std::function&lt;T(T)&gt;</code>类型，所以需要显式地指定模板的类型，另一种方法，我觉得可以使用偏特化。</p>
</li>
<li><p>可变参数模板</p>
<p>==模板参数列表和函数参数列表==：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// template parameter list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span>  <span class="comment">// function parameter list</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++ 11提供了一个用省略号表示的元运算符（meta-operator），能够声明表示模板参数包的标识符。模板参数包是一个类型列表，同样地，它可以用于声明函数参数包的标识符，而函数参数包是一个值列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;  <span class="comment">// Args is a template parameter pack</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Args... args)</span>  <span class="comment">// args is a function parameter pack</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==展开参数包==：</p>
<p>可将省略号放在函数参数包的右边，将参数包展开：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;  <span class="comment">// Args is a template parameter pack</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Args... args)</span>  <span class="comment">// args is a function parameter pack</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    show(args...);  <span class="comment">// passes unpacked args to show()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在可变模板中，可指定展开模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(Args... args)  <span class="comment">// pass by value</span></span><br><span class="line">func(Args&amp;... args)  <span class="comment">// pass by reference</span></span><br><span class="line">func(Args&amp;... args)  <span class="comment">// pass by const reference</span></span><br></pre></td></tr></table></figure>


<p>==使用递归处理可变参数==：</p>
<p>核心理念：将函数参数包展开，对列表中的第一项进行处理，再将余下的内容传递给递归调用，直到列表为空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// terminating call</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;  <span class="comment">// Args is a template parameter pack</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T, value, Args... args)</span>  <span class="comment">// args is a function parameter pack</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// do something with value</span></span><br><span class="line">    func(args...);  <span class="comment">// passes unpacked args to func()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/09/03/CPP%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="clm37cooj000ajsw2el3a1mg4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CPP/" rel="tag">CPP</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/05/15/%E9%95%BF%E5%BE%81%E4%BA%94%E5%8F%B7%E9%81%A5%E4%B8%89%E8%BF%90%E8%BD%BD%E7%81%AB%E7%AE%AD%E7%BA%B8%E6%A8%A1%E5%9E%8B%E5%88%B6%E4%BD%9C/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">长征五号遥三运载火箭纸模型制作</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/%E7%AE%97%E6%B3%95/">算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/misc/">misc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BC%98%E5%8C%96/">优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/">个人网站</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/">常用工具整理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/">版本控制</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%B8%90%E5%8F%98%E7%AE%97%E6%B3%95/">渐变算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E8%BD%A6%E9%81%93%E7%BA%BF%E6%A3%80%E6%B5%8B/">车道线检测</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80/Latex/">Latex</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPP/" rel="tag">CPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DVC/" rel="tag">DVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Latex/" rel="tag">Latex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode%E5%88%B7%E9%A2%98/" rel="tag">LeetCode刷题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/misc/" rel="tag">misc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/" rel="tag">代码管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/" rel="tag">实例分割</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/" rel="tag">常用工具整理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/" rel="tag">数据管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/" rel="tag">整数规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%90%E5%8F%98%E8%BF%87%E6%B8%A1/" rel="tag">渐变过渡</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%A6%E9%81%93%E7%BA%BF%E6%A3%80%E6%B5%8B/" rel="tag">车道线检测</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CPP/" style="font-size: 15px;">CPP</a> <a href="/tags/DVC/" style="font-size: 10px;">DVC</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Latex/" style="font-size: 10px;">Latex</a> <a href="/tags/LeetCode%E5%88%B7%E9%A2%98/" style="font-size: 10px;">LeetCode刷题</a> <a href="/tags/misc/" style="font-size: 20px;">misc</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/" style="font-size: 10px;">代码管理</a> <a href="/tags/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/" style="font-size: 10px;">实例分割</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/" style="font-size: 10px;">常用工具整理</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/" style="font-size: 10px;">数据管理</a> <a href="/tags/%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/" style="font-size: 10px;">整数规划</a> <a href="/tags/%E6%B8%90%E5%8F%98%E8%BF%87%E6%B8%A1/" style="font-size: 10px;">渐变过渡</a> <a href="/tags/%E8%BD%A6%E9%81%93%E7%BA%BF%E6%A3%80%E6%B5%8B/" style="font-size: 10px;">车道线检测</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/03/CPP%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">C++复习笔记</a>
          </li>
        
          <li>
            <a href="/2023/05/15/%E9%95%BF%E5%BE%81%E4%BA%94%E5%8F%B7%E9%81%A5%E4%B8%89%E8%BF%90%E8%BD%BD%E7%81%AB%E7%AE%AD%E7%BA%B8%E6%A8%A1%E5%9E%8B%E5%88%B6%E4%BD%9C/">长征五号遥三运载火箭纸模型制作</a>
          </li>
        
          <li>
            <a href="/2023/05/13/%E4%B8%98%E6%AF%94%E7%89%B9%E4%B9%8B%E7%AE%AD/">丘比特之箭</a>
          </li>
        
          <li>
            <a href="/2023/04/16/%E5%A4%A7%E5%AD%A6%E4%B8%8E%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8/">大学与四轴飞行器</a>
          </li>
        
          <li>
            <a href="/2023/04/16/%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%97%B6%E5%80%99%E5%86%99%E4%B8%8B%E7%9A%84%E4%B8%80%E6%AE%B5SQL%E6%9F%A5%E8%AF%A2/">大学的时候写下的一段SQL查询</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 movic<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>